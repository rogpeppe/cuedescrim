./schemastore/src/schemas/json/appveyor.cue:7:1: #command
0: ./schemastore/src/schemas/json/appveyor.cue:7:22: string
1: ./schemastore/src/schemas/json/appveyor.cue:7:30: {}
2: ./schemastore/src/schemas/json/appveyor.cue:10:5: {}
3: ./schemastore/src/schemas/json/appveyor.cue:13:5: {}
4: ./schemastore/src/schemas/json/appveyor.cue:15:5: {}
discriminate {0, 1, 2, 3, 4} {
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 2, 3, 4}
	discriminate {1, 2, 3, 4} {
		no pure discriminator found; trying existence checks; selected {1, 2, 3, 4}
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({0})
case struct:
	choose({1, 2, 3, 4})
}
./schemastore/src/schemas/json/architectfx.cue:19:1: #config
0: ./schemastore/src/schemas/json/architectfx.cue:19:21: {
	".field"!: string
	".value"!: _
}
1: ./schemastore/src/schemas/json/architectfx.cue:25:5: {
	".method"!: string
}
discriminate {0, 1} {
	----- PATH .field
	values:
	kinds:
		string: {0}
	----- PATH .value
	values:
	kinds:
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
		null: {0}
		bool: {0}
	----- PATH .method
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH .field {1}; possible {0, 1}
	it's possible!
	----- PATH .value {1}; possible {1}
	it's possible!
	nothing removed
	----- PATH .method {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(.field) -> {1}
	notPresent(.method) -> {0}
}
./schemastore/src/schemas/json/bun-lock.cue:87:1: #BunLockFilePackageArray
0: ./schemastore/src/schemas/json/bun-lock.cue:87:38: [string, string, {}, string, ...]
1: ./schemastore/src/schemas/json/bun-lock.cue:87:133: [string, {}, ...]
2: ./schemastore/src/schemas/json/bun-lock.cue:87:206: [string, ...]
3: ./schemastore/src/schemas/json/bun-lock.cue:87:251: [string, {}, string, ...]
4: ./schemastore/src/schemas/json/bun-lock.cue:87:335: [string, {}, ...]
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})
./schemastore/src/schemas/json/bunfig.cue:95:2: test.coverageThreshold
0: ./schemastore/src/schemas/json/bunfig.cue:95:33: int
1: ./schemastore/src/schemas/json/bunfig.cue:95:38: number
2: ./schemastore/src/schemas/json/bunfig.cue:95:46: {}
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/bxci.schema-3.x.cue:312:1: #outputHelmUpdatesProperties
0: ./schemastore/src/schemas/json/bxci.schema-3.x.cue:312:42: {
	key!: string
	env!: =~"^[A-Za-z_][A-Za-z0-9_]*$"
}
1: ./schemastore/src/schemas/json/bxci.schema-3.x.cue:320:5: {
	key!:   string
	value!: string
}
discriminate {0, 1} {
	----- PATH key
	values:
	kinds:
		string: {0, 1}
	----- PATH env
	values:
	kinds:
		string: {0}
	----- PATH value
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH key {}; possible {0, 1}
	----- PATH env {1}; possible {0, 1}
	it's possible!
	----- PATH value {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(env) -> {1}
	notPresent(value) -> {0}
}
./schemastore/src/schemas/json/cargo-make.cue:245:1: #script
0: ./schemastore/src/schemas/json/cargo-make.cue:245:21: string
1: ./schemastore/src/schemas/json/cargo-make.cue:245:29: [...string]
2: ./schemastore/src/schemas/json/cargo-make.cue:245:42: {
	file!: string
}
3: ./schemastore/src/schemas/json/cargo-make.cue:253:5: {}
discriminate {0, 1, 2, 3} {
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind struct: {2, 3}
	discriminate {2, 3} {
		----- PATH file
		values:
		kinds:
			string: {2}
		no pure discriminator found; trying existence checks; selected {2, 3}
		----- PATH file {3}; possible {2, 3}
		it's possible!
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({0})
case list:
	choose({1})
case struct:
	choose({2, 3})
}

./schemastore/src/schemas/json/cargo-make.cue:386:2: #task.install_crate
0: ./schemastore/src/schemas/json/cargo-make.cue:386:29: bool
1: ./schemastore/src/schemas/json/cargo-make.cue:386:35: string
2: ./schemastore/src/schemas/json/cargo-make.cue:386:43: {
	crate_name!: string
	binary!:     string
	test_arg!: matchN(1, [string, [...string]])
}
3: ./schemastore/src/schemas/json/cargo-make.cue:421:6: {
	rustup_component_name!: string
}
4: ./schemastore/src/schemas/json/cargo-make.cue:438:6: {
	crate_name!:  string
	min_version!: =~"^(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(?:-((?:0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
}
discriminate {0, 1, 2, 3, 4} {
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind struct: {2, 3, 4}
	discriminate {2, 3, 4} {
		----- PATH crate_name
		values:
		kinds:
			string: {2, 4}
		----- PATH binary
		values:
		kinds:
			string: {2}
		----- PATH test_arg
		values:
		kinds:
			float: {2}
			string: {2}
			bytes: {2}
			list: {2}
			struct: {2}
			null: {2}
			bool: {2}
			int: {2}
		----- PATH rustup_component_name
		values:
		kinds:
			string: {3}
		----- PATH min_version
		values:
		kinds:
			string: {4}
		no pure discriminator found; trying existence checks; selected {2, 3, 4}
		----- PATH crate_name {3}; possible {2, 3, 4}
		----- PATH binary {3, 4}; possible {2, 3, 4}
		it's possible!
		----- PATH test_arg {3, 4}; possible {3, 4}
		it's possible!
		nothing removed
		----- PATH rustup_component_name {2, 4}; possible {3, 4}
		it's possible!
		----- PATH min_version {2, 3}; possible {4}
		it's possible!
	} -> *cuediscrim.FieldAbsenceNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case bool:
	choose({0})
case string:
	choose({1})
case struct:
	allOf {
		notPresent(binary) -> {3, 4}
		notPresent(min_version) -> {2, 3}
		notPresent(rustup_component_name) -> {2, 4}
	}
}
./schemastore/src/schemas/json/clang-tidy.cue:30:1: FormatStyle
0: ./schemastore/src/schemas/json/clang-tidy.cue:30:26: "none"
1: ./schemastore/src/schemas/json/clang-tidy.cue:30:35: "file"
2: ./schemastore/src/schemas/json/clang-tidy.cue:30:44: "llvm"
3: ./schemastore/src/schemas/json/clang-tidy.cue:30:53: "google"
4: ./schemastore/src/schemas/json/clang-tidy.cue:30:64: "webkit"
5: ./schemastore/src/schemas/json/clang-tidy.cue:30:75: "mozilla"
6: ./schemastore/src/schemas/json/clang-tidy.cue:30:86: =~"\\{.*\\}"
discriminate {0, 1, 2, 3, 4, 5, 6} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6})
./schemastore/src/schemas/json/compilerdefaults.cue:128:2: compilers.less.cssComb
0: ./schemastore/src/schemas/json/compilerdefaults.cue:128:23: "csscomb"
1: ./schemastore/src/schemas/json/compilerdefaults.cue:128:35: "zen"
2: ./schemastore/src/schemas/json/compilerdefaults.cue:128:43: "yandex"
3: ./schemastore/src/schemas/json/compilerdefaults.cue:128:54: "none"
4: ./schemastore/src/schemas/json/compilerdefaults.cue:128:62: =~".+\\.json$"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/compilerdefaults.cue:128:2: #less.cssComb
0: ./schemastore/src/schemas/json/compilerdefaults.cue:128:23: "csscomb"
1: ./schemastore/src/schemas/json/compilerdefaults.cue:128:35: "zen"
2: ./schemastore/src/schemas/json/compilerdefaults.cue:128:43: "yandex"
3: ./schemastore/src/schemas/json/compilerdefaults.cue:128:54: "none"
4: ./schemastore/src/schemas/json/compilerdefaults.cue:128:62: =~".+\\.json$"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})
./schemastore/src/schemas/json/component.cue:47:2: scripts
0: ./schemastore/src/schemas/json/component.cue:47:23: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:49:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:55:2: styles
0: ./schemastore/src/schemas/json/component.cue:55:22: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:57:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:63:2: json
0: ./schemastore/src/schemas/json/component.cue:63:20: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:65:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:71:2: images
0: ./schemastore/src/schemas/json/component.cue:71:22: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:73:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:79:2: fonts
0: ./schemastore/src/schemas/json/component.cue:79:21: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:81:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:88:2: files
0: ./schemastore/src/schemas/json/component.cue:88:21: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:90:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:97:2: dependencies
0: ./schemastore/src/schemas/json/component.cue:97:28: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:99:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:106:2: locals
0: ./schemastore/src/schemas/json/component.cue:106:22: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:108:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:115:2: remotes
0: ./schemastore/src/schemas/json/component.cue:115:23: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:117:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:122:2: paths
0: ./schemastore/src/schemas/json/component.cue:122:21: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:124:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:129:2: templates
0: ./schemastore/src/schemas/json/component.cue:129:25: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:131:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:47:2: _schema.scripts
0: ./schemastore/src/schemas/json/component.cue:47:23: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:49:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:55:2: _schema.styles
0: ./schemastore/src/schemas/json/component.cue:55:22: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:57:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:63:2: _schema.json
0: ./schemastore/src/schemas/json/component.cue:63:20: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:65:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:71:2: _schema.images
0: ./schemastore/src/schemas/json/component.cue:71:22: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:73:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:79:2: _schema.fonts
0: ./schemastore/src/schemas/json/component.cue:79:21: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:81:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:88:2: _schema.files
0: ./schemastore/src/schemas/json/component.cue:88:21: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:90:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:97:2: _schema.dependencies
0: ./schemastore/src/schemas/json/component.cue:97:28: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:99:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:106:2: _schema.locals
0: ./schemastore/src/schemas/json/component.cue:106:22: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:108:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:115:2: _schema.remotes
0: ./schemastore/src/schemas/json/component.cue:115:23: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:117:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:122:2: _schema.paths
0: ./schemastore/src/schemas/json/component.cue:122:21: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:124:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/component.cue:129:2: _schema.templates
0: ./schemastore/src/schemas/json/component.cue:129:25: [string | {}, ...string | {}]
1: ./schemastore/src/schemas/json/component.cue:131:6: struct.MinFields(1) & close({
	[string]: string
})
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/dart-test.cue:41:1: #foldStackFrameOptions
0: ./schemastore/src/schemas/json/dart-test.cue:41:36: {}
1: ./schemastore/src/schemas/json/dart-test.cue:43:5: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/dart-test.cue:176:1: #timeout
0: ./schemastore/src/schemas/json/dart-test.cue:176:22: "none"
1: ./schemastore/src/schemas/json/dart-test.cue:176:30: =~"^(?:[^a-df-zA-DF-Z\\s]+(?:[umUM][sS]|[dhmsDHMS])\\s?)+$"
2: ./schemastore/src/schemas/json/dart-test.cue:176:91: =~"^[^a-df-zA-DF-Z\\s]+[xX]$"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:1: #bool
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:19: bool
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:25: =~"\\$\\{(resources(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:101: =~"\\$\\{(bundle(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:174: =~"\\$\\{(workspace(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:250: =~"\\$\\{(artifacts(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:21:326: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:1: #float64
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:22: number
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:30: =~"\\$\\{(resources(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:106: =~"\\$\\{(bundle(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:179: =~"\\$\\{(workspace(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:255: =~"\\$\\{(artifacts(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:23:331: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:1: #int
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:18: int
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:23: =~"\\$\\{(resources(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:99: =~"\\$\\{(bundle(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:172: =~"\\$\\{(workspace(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:248: =~"\\$\\{(artifacts(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:25:324: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:1: #int64
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:20: int
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:25: =~"\\$\\{(resources(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:101: =~"\\$\\{(bundle(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:174: =~"\\$\\{(workspace(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:250: =~"\\$\\{(artifacts(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:27:326: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1112:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.AppDeploymentMode"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1112:101: "SNAPSHOT"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1112:114: "AUTO_SYNC"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1112:127: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1114:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.AppDeploymentState"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1114:102: "SUCCEEDED"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1114:116: "FAILED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1114:127: "IN_PROGRESS"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1114:143: "CANCELLED"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1114:156: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1135:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.AppResourceJobJobPermission"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1135:111: "CAN_MANAGE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1135:126: "IS_OWNER"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1135:139: "CAN_MANAGE_RUN"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1135:158: "CAN_VIEW"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1135:170: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1143:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.AppResourceSecretSecretPermission"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1143:117: "READ"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1143:126: "WRITE"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1143:136: "MANAGE"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1143:146: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1150:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.AppResourceServingEndpointServingEndpointPermission"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1150:135: "CAN_MANAGE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1150:150: "CAN_QUERY"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1150:164: "CAN_VIEW"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1150:176: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1157:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.AppResourceSqlWarehouseSqlWarehousePermission"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1157:129: "CAN_MANAGE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1157:144: "CAN_USE"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1157:156: "IS_OWNER"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1157:168: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1159:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.ApplicationState"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1159:100: "DEPLOYING"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1159:114: "RUNNING"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1159:126: "CRASHED"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1159:138: "UNAVAILABLE"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1159:153: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/apps.ComputeState"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:96: "ERROR"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:106: "DELETING"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:119: "STARTING"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:132: "STOPPING"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:145: "UPDATING"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:158: "STOPPED"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:170: "ACTIVE"
7: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1166:180: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1187:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/catalog.MonitorCronSchedulePauseStatus"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1187:117: "UNPAUSED"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1187:130: "PAUSED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1187:140: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1241:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/catalog.MonitorInferenceLogProblemType"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1241:117: "PROBLEM_TYPE_CLASSIFICATION"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1241:149: "PROBLEM_TYPE_REGRESSION"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1241:176: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1279:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/catalog.MonitorMetricType"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1279:104: "CUSTOM_METRIC_TYPE_AGGREGATE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1279:137: "CUSTOM_METRIC_TYPE_DERIVED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1279:168: "CUSTOM_METRIC_TYPE_DRIFT"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1279:196: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1310:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/catalog.VolumeType"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1310:97: "EXTERNAL"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1310:110: "MANAGED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1310:121: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1451:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/compute.AwsAvailability"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1451:102: "SPOT"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1451:111: "ON_DEMAND"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1451:125: "SPOT_WITH_FALLBACK"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1451:147: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1486:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/compute.AzureAvailability"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1486:104: "SPOT_AZURE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1486:119: "ON_DEMAND_AZURE"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1486:139: "SPOT_WITH_FALLBACK_AZURE"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1486:167: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/compute.DataSecurityMode"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:103: "DATA_SECURITY_MODE_AUTO"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:131: "DATA_SECURITY_MODE_STANDARD"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:163: "DATA_SECURITY_MODE_DEDICATED"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:196: "NONE"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:205: "SINGLE_USER"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:221: "USER_ISOLATION"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:240: "LEGACY_TABLE_ACL"
7: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:261: "LEGACY_PASSTHROUGH"
8: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:284: "LEGACY_SINGLE_USER"
9: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:307: "LEGACY_SINGLE_USER_STANDARD"
10: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1705:338: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1727:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/compute.EbsVolumeType"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1727:100: "GENERAL_PURPOSE_SSD"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1727:124: "THROUGHPUT_OPTIMIZED_HDD"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1727:152: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1791:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/compute.GcpAvailability"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1791:102: "PREEMPTIBLE_GCP"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1791:122: "ON_DEMAND_GCP"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1791:140: "PREEMPTIBLE_WITH_FALLBACK_GCP"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1791:173: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:1937:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/compute.RuntimeEngine"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1937:100: "NULL"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1937:109: "STANDARD"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1937:122: "PHOTON"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:1937:132: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2004:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/dashboards.LifecycleState"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2004:104: "ACTIVE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2004:115: "TRASHED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2004:126: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2023:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.Condition"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2023:93: "ANY_UPDATED"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2023:109: "ALL_UPDATED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2023:124: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.ConditionTaskOp"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:99: "EQUAL_TO"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:112: "GREATER_THAN"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:129: "GREATER_THAN_OR_EQUAL"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:155: "LESS_THAN"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:169: "LESS_THAN_OR_EQUAL"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:192: "NOT_EQUAL"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2049:205: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.GitProvider"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:95: "gitHub"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:106: "bitbucketCloud"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:125: "azureDevOpsServices"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:149: "gitHubEnterprise"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:170: "bitbucketServer"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:190: "gitLab"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:201: "gitLabEnterpriseEdition"
7: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:229: "awsCodeCommit"
8: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2158:246: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.JobsHealthMetric"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:100: "RUN_DURATION_SECONDS"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:125: "STREAMING_BACKLOG_BYTES"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:153: "STREAMING_BACKLOG_RECORDS"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:183: "STREAMING_BACKLOG_SECONDS"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:213: "STREAMING_BACKLOG_FILES"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2276:240: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2278:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.JobsHealthOperator"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2278:102: "GREATER_THAN"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2278:118: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2342:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.PauseStatus"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2342:95: "UNPAUSED"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2342:108: "PAUSED"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2342:118: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2352:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.PeriodicTriggerConfigurationTimeUnit"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2352:120: "HOURS"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2352:130: "DAYS"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2352:139: "WEEKS"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2352:148: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.RunIf"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:89: "ALL_SUCCESS"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:105: "ALL_DONE"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:118: "NONE_FAILED"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:134: "AT_LEAST_ONE_SUCCESS"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:159: "ALL_FAILED"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:174: "AT_LEAST_ONE_FAILED"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2391:197: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:2496:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/jobs.Source"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2496:90: "WORKSPACE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2496:104: "GIT"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:2496:111: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3031:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/ml.ModelVersionStatus"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3031:100: "PENDING_REGISTRATION"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3031:125: "FAILED_REGISTRATION"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3031:149: "READY"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3031:158: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/pipelines.DayOfWeek"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:98: "MONDAY"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:109: "TUESDAY"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:121: "WEDNESDAY"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:135: "THURSDAY"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:148: "FRIDAY"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:159: "SATURDAY"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:172: "SUNDAY"
7: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3046:182: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3048:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/pipelines.DeploymentKind"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3048:103: "BUNDLE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3048:113: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3317:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/pipelines.PipelineClusterAutoscaleMode"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3317:117: "ENHANCED"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3317:130: "LEGACY"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3317:140: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3462:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/pipelines.TableSpecificConfigScdType"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3462:115: "SCD_TYPE_1"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3462:130: "SCD_TYPE_2"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3462:144: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3528:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.AiGatewayGuardrailPiiBehaviorBehavior"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3528:124: "NONE"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3528:133: "BLOCK"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3528:142: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3574:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.AiGatewayRateLimitKey"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3574:108: "user"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3574:117: "endpoint"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3574:129: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3576:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.AiGatewayRateLimitRenewalPeriod"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3576:118: "minute"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3576:128: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3625:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.AmazonBedrockConfigBedrockProvider"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3625:121: "anthropic"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3625:135: "cohere"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3625:146: "ai21labs"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3625:159: "amazon"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3625:169: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.ExternalModelProvider"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:108: "ai21labs"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:121: "anthropic"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:135: "amazon-bedrock"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:154: "cohere"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:165: "databricks-model-serving"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:194: "google-cloud-vertex-ai"
6: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:221: "openai"
7: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:232: "palm"
8: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3778:240: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3918:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.RateLimitKey"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3918:99: "user"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3918:108: "endpoint"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3918:120: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:3920:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.RateLimitRenewalPeriod"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3920:109: "minute"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:3920:119: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:4081:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.ServedModelInputWorkloadSize"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4081:115: "Small"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4081:125: "Medium"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4081:136: "Large"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4081:145: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:9: _#defs."/$defs/github.com/databricks/databricks-sdk-go/service/serving.ServedModelInputWorkloadType"
0: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:115: "CPU"
1: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:123: "GPU_SMALL"
2: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:137: "GPU_MEDIUM"
3: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:152: "GPU_LARGE"
4: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:166: "MULTIGPU_MEDIUM"
5: ./schemastore/src/schemas/json/databricks-asset-bundles.cue:4083:185: =~"\\$\\{(var(\\.[a-zA-Z]+([-_]?[a-zA-Z0-9]+)*(\\[[0-9]+\\])*)+)\\}"
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})
./schemastore/src/schemas/json/dein.cue:42:4: #."on_map-array"
0: ./schemastore/src/schemas/json/dein.cue:42:31: [...]
1: ./schemastore/src/schemas/json/dein.cue:42:50: [...string]
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/dein.cue:52:4: #."on_map-string"
0: ./schemastore/src/schemas/json/dein.cue:52:32: =~"^[nvxsomilct]+$"
1: ./schemastore/src/schemas/json/dein.cue:52:74: string
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/dein.cue:84:2: #Plugin.repo
0: ./schemastore/src/schemas/json/dein.cue:84:20: =~"^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$"
1: ./schemastore/src/schemas/json/dein.cue:84:26: =~"^[~|/][a-zA-Z-_0-9/\\.~]+$"
2: ./schemastore/src/schemas/json/dein.cue:84:33: =~"^[a-zA-Z-_0-9]+/[a-zA-Z-_0-9\\.]+$"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/dein.cue:157:2: #Plugin.on_map
0: ./schemastore/src/schemas/json/dein.cue:157:22: {}
1: ./schemastore/src/schemas/json/dein.cue:42:31: [...]
2: ./schemastore/src/schemas/json/dein.cue:42:50: [...string]
3: ./schemastore/src/schemas/json/dein.cue:52:32: =~"^[nvxsomilct]+$"
4: ./schemastore/src/schemas/json/dein.cue:52:74: string
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})
./schemastore/src/schemas/json/expo-50.0.0.cue:49:3: expo.runtimeVersion
0: ./schemastore/src/schemas/json/expo-50.0.0.cue:49:31: =~"^[a-zA-Z\\d][a-zA-Z\\d._+()-]{0,254}$"
1: ./schemastore/src/schemas/json/expo-50.0.0.cue:49:74: =~"^exposdk:((\\d+\\.\\d+\\.\\d+)|(UNVERSIONED))$"
2: ./schemastore/src/schemas/json/expo-50.0.0.cue:49:126: {
	policy!: "nativeVersion" | "sdkVersion" | "appVersion" | "fingerprint"
}
discriminate {0, 1, 2} {
	----- PATH policy
	values:
		"nativeVersion": {2}
		"sdkVersion": {2}
		"appVersion": {2}
		"fingerprint": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH policy {0, 1}; possible {0, 1, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/expo-50.0.0.cue:579:4: expo.ios.runtimeVersion
0: ./schemastore/src/schemas/json/expo-50.0.0.cue:579:32: =~"^[a-zA-Z\\d][a-zA-Z\\d._+()-]{0,254}$"
1: ./schemastore/src/schemas/json/expo-50.0.0.cue:579:75: =~"^exposdk:((\\d+\\.\\d+\\.\\d+)|(UNVERSIONED))$"
2: ./schemastore/src/schemas/json/expo-50.0.0.cue:579:127: {
	policy!: "nativeVersion" | "sdkVersion" | "appVersion" | "fingerprint"
}
discriminate {0, 1, 2} {
	----- PATH policy
	values:
		"fingerprint": {2}
		"nativeVersion": {2}
		"sdkVersion": {2}
		"appVersion": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH policy {0, 1}; possible {0, 1, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/expo-50.0.0.cue:920:4: expo.android.runtimeVersion
0: ./schemastore/src/schemas/json/expo-50.0.0.cue:920:32: =~"^[a-zA-Z\\d][a-zA-Z\\d._+()-]{0,254}$"
1: ./schemastore/src/schemas/json/expo-50.0.0.cue:920:75: =~"^exposdk:((\\d+\\.\\d+\\.\\d+)|(UNVERSIONED))$"
2: ./schemastore/src/schemas/json/expo-50.0.0.cue:920:127: {
	policy!: "nativeVersion" | "sdkVersion" | "appVersion" | "fingerprint"
}
discriminate {0, 1, 2} {
	----- PATH policy
	values:
		"nativeVersion": {2}
		"sdkVersion": {2}
		"appVersion": {2}
		"fingerprint": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH policy {0, 1}; possible {0, 1, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/expo-52.0.0.cue:48:3: expo.runtimeVersion
0: ./schemastore/src/schemas/json/expo-52.0.0.cue:48:31: =~"^[a-zA-Z\\d][a-zA-Z\\d._+()-]{0,254}$"
1: ./schemastore/src/schemas/json/expo-52.0.0.cue:48:74: =~"^exposdk:((\\d+\\.\\d+\\.\\d+)|(UNVERSIONED))$"
2: ./schemastore/src/schemas/json/expo-52.0.0.cue:48:126: {
	policy!: "nativeVersion" | "sdkVersion" | "appVersion" | "fingerprint"
}
discriminate {0, 1, 2} {
	----- PATH policy
	values:
		"nativeVersion": {2}
		"sdkVersion": {2}
		"appVersion": {2}
		"fingerprint": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH policy {0, 1}; possible {0, 1, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/expo-52.0.0.cue:608:4: expo.ios.runtimeVersion
0: ./schemastore/src/schemas/json/expo-52.0.0.cue:608:32: =~"^[a-zA-Z\\d][a-zA-Z\\d._+()-]{0,254}$"
1: ./schemastore/src/schemas/json/expo-52.0.0.cue:608:75: =~"^exposdk:((\\d+\\.\\d+\\.\\d+)|(UNVERSIONED))$"
2: ./schemastore/src/schemas/json/expo-52.0.0.cue:608:127: {
	policy!: "nativeVersion" | "sdkVersion" | "appVersion" | "fingerprint"
}
discriminate {0, 1, 2} {
	----- PATH policy
	values:
		"nativeVersion": {2}
		"sdkVersion": {2}
		"fingerprint": {2}
		"appVersion": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH policy {0, 1}; possible {0, 1, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/expo-52.0.0.cue:949:4: expo.android.runtimeVersion
0: ./schemastore/src/schemas/json/expo-52.0.0.cue:949:32: =~"^[a-zA-Z\\d][a-zA-Z\\d._+()-]{0,254}$"
1: ./schemastore/src/schemas/json/expo-52.0.0.cue:949:75: =~"^exposdk:((\\d+\\.\\d+\\.\\d+)|(UNVERSIONED))$"
2: ./schemastore/src/schemas/json/expo-52.0.0.cue:949:127: {
	policy!: "nativeVersion" | "sdkVersion" | "appVersion" | "fingerprint"
}
discriminate {0, 1, 2} {
	----- PATH policy
	values:
		"sdkVersion": {2}
		"appVersion": {2}
		"nativeVersion": {2}
		"fingerprint": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH policy {0, 1}; possible {0, 1, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/function.cue:140:1: #httpBinding
0: ./schemastore/src/schemas/json/function.cue:140:26: null
1: ./schemastore/src/schemas/json/function.cue:140:33: bool
2: ./schemastore/src/schemas/json/function.cue:140:40: number
3: ./schemastore/src/schemas/json/function.cue:140:49: string
4: -: [...]
5: -: {}
6: ./schemastore/src/schemas/json/function.cue:155:4: null
7: ./schemastore/src/schemas/json/function.cue:155:11: bool
8: ./schemastore/src/schemas/json/function.cue:155:18: number
9: ./schemastore/src/schemas/json/function.cue:155:27: string
10: -: [...]
11: -: {}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11})
./schemastore/src/schemas/json/github-workflow.cue:312:1: #matrix
0: ./schemastore/src/schemas/json/github-workflow.cue:312:21: struct.MinFields(1) & close({
	{
		[=~"^(in|ex)clude$"]: matchN(1, [#expressionSyntax, [...close({
			[string]: #configuration
		})] & [_, ...]])
	}
	{
		[!~"^(in|ex)clude$" & !~"^()$"]: matchN(1, [[...#configuration] & [_, ...], #expressionSyntax])
	}
})
1: ./schemastore/src/schemas/json/github-workflow.cue:318:5: =~"""
	^\\$\\{\\{(.|[\r
	])*\\}\\}$
	"""
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/github-workflow.cue:507:2: #reusableWorkflowCallJob.secrets
0: ./schemastore/src/schemas/json/github-workflow.cue:262:18: {}
1: ./schemastore/src/schemas/json/github-workflow.cue:264:5: =~"""
	^.*\\$\\{\\{(.|[\r
	])*\\}\\}.*$
	"""
2: ./schemastore/src/schemas/json/github-workflow.cue:507:29: "inherit"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/jasonette.cue:65:2: #action.type
0: ./schemastore/src/schemas/json/jasonette.cue:65:20: string
1: ./schemastore/src/schemas/json/jasonette.cue:103:22: "$render"
2: ./schemastore/src/schemas/json/jasonette.cue:103:34: "$reload"
3: ./schemastore/src/schemas/json/jasonette.cue:103:46: "$snapshot"
4: ./schemastore/src/schemas/json/jasonette.cue:103:60: "$href"
5: ./schemastore/src/schemas/json/jasonette.cue:103:70: "$close"
6: ./schemastore/src/schemas/json/jasonette.cue:103:81: "$back"
7: ./schemastore/src/schemas/json/jasonette.cue:103:91: "$network.request"
8: ./schemastore/src/schemas/json/jasonette.cue:103:112: "$network.upload"
9: ./schemastore/src/schemas/json/jasonette.cue:103:132: "$session.set"
10: ./schemastore/src/schemas/json/jasonette.cue:103:149: "$session.reset"
11: ./schemastore/src/schemas/json/jasonette.cue:103:168: "$set"
12: ./schemastore/src/schemas/json/jasonette.cue:103:177: "$get"
13: ./schemastore/src/schemas/json/jasonette.cue:103:186: "$cache.set"
14: ./schemastore/src/schemas/json/jasonette.cue:103:201: "$cache.reset"
15: ./schemastore/src/schemas/json/jasonette.cue:103:218: "$global.set"
16: ./schemastore/src/schemas/json/jasonette.cue:103:234: "$global.reset"
17: ./schemastore/src/schemas/json/jasonette.cue:103:252: "$util.banner"
18: ./schemastore/src/schemas/json/jasonette.cue:103:269: "$util.toast"
19: ./schemastore/src/schemas/json/jasonette.cue:103:285: "$util.alert"
20: ./schemastore/src/schemas/json/jasonette.cue:103:301: "$util.share"
21: ./schemastore/src/schemas/json/jasonette.cue:103:317: "$util.picker"
22: ./schemastore/src/schemas/json/jasonette.cue:103:334: "$util.datepicker"
23: ./schemastore/src/schemas/json/jasonette.cue:103:355: "$util.addressbook"
24: ./schemastore/src/schemas/json/jasonette.cue:103:377: "$media.camera"
25: ./schemastore/src/schemas/json/jasonette.cue:103:395: "$media.picker"
26: ./schemastore/src/schemas/json/jasonette.cue:103:413: "media.player"
27: ./schemastore/src/schemas/json/jasonette.cue:103:430: "$audio.play"
28: ./schemastore/src/schemas/json/jasonette.cue:103:446: "$audio.pause"
29: ./schemastore/src/schemas/json/jasonette.cue:103:463: "$audio.stop"
30: ./schemastore/src/schemas/json/jasonette.cue:103:479: "$audio.seek"
31: ./schemastore/src/schemas/json/jasonette.cue:103:495: "$audio.position"
32: ./schemastore/src/schemas/json/jasonette.cue:103:515: "$audio.duration"
33: ./schemastore/src/schemas/json/jasonette.cue:103:535: "audio.record"
34: ./schemastore/src/schemas/json/jasonette.cue:103:552: "$geo.get"
35: ./schemastore/src/schemas/json/jasonette.cue:103:565: "$timer.start"
36: ./schemastore/src/schemas/json/jasonette.cue:103:582: "$timer.stop"
37: ./schemastore/src/schemas/json/jasonette.cue:103:598: "$convert.csv"
38: ./schemastore/src/schemas/json/jasonette.cue:103:615: "$convert.rss"
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38})
./schemastore/src/schemas/json/jscpd.cue:129:1: #color
0: ./schemastore/src/schemas/json/jscpd.cue:133:15: "green"
1: ./schemastore/src/schemas/json/jscpd.cue:133:25: "blue"
2: ./schemastore/src/schemas/json/jscpd.cue:133:34: "red"
3: ./schemastore/src/schemas/json/jscpd.cue:133:42: "yellow"
4: ./schemastore/src/schemas/json/jscpd.cue:133:53: "orange"
5: ./schemastore/src/schemas/json/jscpd.cue:133:64: "purple"
6: ./schemastore/src/schemas/json/jscpd.cue:133:75: "pink"
7: ./schemastore/src/schemas/json/jscpd.cue:133:84: "grey"
8: ./schemastore/src/schemas/json/jscpd.cue:133:93: "gray"
9: ./schemastore/src/schemas/json/jscpd.cue:133:102: "cyan"
10: ./schemastore/src/schemas/json/jscpd.cue:133:111: "black"
11: ./schemastore/src/schemas/json/jscpd.cue:129:34: =~"([0-9a-fA-F]{3}){1,2}"
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11})
./schemastore/src/schemas/json/jscsrc.cue:134:1: disallowNewlineBeforeBlockStatements
0: ./schemastore/src/schemas/json/jscsrc.cue:1100:17: null
1: -: [..."catch" | "do" | "else" | "finally" | "for" | "function" | "if" | "try" | "while"]
2: ./schemastore/src/schemas/json/jscsrc.cue:136:5: bool
3: ./schemastore/src/schemas/json/jscsrc.cue:136:11: null
4: ./schemastore/src/schemas/json/jscsrc.cue:138:5: {}
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/jscsrc.cue:814:1: requireSpaceBeforeKeywords
0: ./schemastore/src/schemas/json/jscsrc.cue:1100:17: null
1: -: [..."catch" | "do" | "else" | "finally" | "for" | "function" | "if" | "try" | "while"]
2: ./schemastore/src/schemas/json/jscsrc.cue:816:5: bool
3: ./schemastore/src/schemas/json/jscsrc.cue:816:11: null
4: ./schemastore/src/schemas/json/jscsrc.cue:818:5: {}
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/jscsrc.cue:992:1: requireYodaConditions
0: ./schemastore/src/schemas/json/jscsrc.cue:1108:21: null
1: ./schemastore/src/schemas/json/jscsrc.cue:1108:28: bool
2: -: [..."==" | "===" | "!=" | "!==" | null]
3: ./schemastore/src/schemas/json/jscsrc.cue:992:80: bool
4: ./schemastore/src/schemas/json/jscsrc.cue:992:86: null
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})
./schemastore/src/schemas/json/kustomization.cue:244:2: #Kustomization.sortOptions
0: ./schemastore/src/schemas/json/kustomization.cue:244:27: {}
1: ./schemastore/src/schemas/json/kustomization.cue:250:6: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/kustomization.cue:306:1: #PatchJson6902
0: ./schemastore/src/schemas/json/kustomization.cue:306:28: {
	path!: string
	target!: {
		kind!:    string
		name!:    string
		version!: string
	}
}
1: ./schemastore/src/schemas/json/kustomization.cue:314:5: {
	patch!: string
	target!: {
		kind!:    string
		name!:    string
		version!: string
	}
}
2: ./schemastore/src/schemas/json/kustomization.cue:322:5: {
	op!:   "add" | "remove" | "replace" | "move" | "copy" | "test"
	path!: string
}
discriminate {0, 1, 2} {
	----- PATH path
	values:
	kinds:
		string: {0, 2}
	----- PATH target
	values:
	kinds:
		struct: {0, 1}
	----- PATH patch
	values:
	kinds:
		string: {1}
	----- PATH op
	values:
		"add": {2}
		"remove": {2}
		"replace": {2}
		"move": {2}
		"copy": {2}
		"test": {2}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH path {1}; possible {0, 1, 2}
	----- PATH target {2}; possible {0, 1, 2}
	----- PATH patch {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH op {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/kustomization.cue:244:2: sortOptions
0: ./schemastore/src/schemas/json/kustomization.cue:244:27: {}
1: ./schemastore/src/schemas/json/kustomization.cue:250:6: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lazydocker.cue:333:1: #color
0: ./schemastore/src/schemas/json/lazydocker.cue:333:20: "black"
1: ./schemastore/src/schemas/json/lazydocker.cue:333:30: "red"
2: ./schemastore/src/schemas/json/lazydocker.cue:333:38: "green"
3: ./schemastore/src/schemas/json/lazydocker.cue:333:48: "yellow"
4: ./schemastore/src/schemas/json/lazydocker.cue:333:59: "blue"
5: ./schemastore/src/schemas/json/lazydocker.cue:333:68: "magenta"
6: ./schemastore/src/schemas/json/lazydocker.cue:333:80: "cyan"
7: ./schemastore/src/schemas/json/lazydocker.cue:333:89: "white"
8: ./schemastore/src/schemas/json/lazydocker.cue:333:99: "bold"
9: ./schemastore/src/schemas/json/lazydocker.cue:333:108: "default"
10: ./schemastore/src/schemas/json/lazydocker.cue:333:120: "reverse"
11: ./schemastore/src/schemas/json/lazydocker.cue:333:132: "underline"
12: ./schemastore/src/schemas/json/lazydocker.cue:333:146: "strikethrough"
13: ./schemastore/src/schemas/json/lazydocker.cue:333:163: =~"^#[0-9a-fA-F]{6}$"
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13})
./schemastore/src/schemas/json/lsdlschema-0.7.cue:37:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:37:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullWord]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:43:5: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullWord]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		null: {0, 1}
		bool: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		int: {0, 1}
		float: {0, 1}
		list: {0, 1}
		struct: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-0.7.cue:69:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:69:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:71:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-0.7.cue:77:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:77:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:82:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:87:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-0.7.cue:144:2: #entity.Binding
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:69:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:71:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:77:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:82:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:87:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:199:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:204:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:213:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:219:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-0.7.cue:199:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:199:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:204:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-0.7.cue:213:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:213:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:219:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-0.7.cue:411:1: #word
0: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:411:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-0.7.cue:411:36: #fullWord
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-1.0.cue:44:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:44:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:50:5: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		string: {0, 1}
		list: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		float: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-1.0.cue:79:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:79:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:81:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-1.0.cue:87:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:87:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:92:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:97:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-1.0.cue:160:2: #entity.Binding
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:79:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:81:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:87:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:92:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:97:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:218:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:223:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:232:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:238:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-1.0.cue:218:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:218:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:223:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-1.0.cue:232:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:232:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:238:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:58: {
	Adjective!: matchN(1, [close({
		Subject!:              #roleReference
		Adjectives!:           #terms
		Antonyms?:             #terms
		Measurement?:          #roleReference
		PrepositionalPhrases?: #prepPhrases
	}), close({
		Subject!:              #roleReference
		Antonyms!:             #terms
		Measurement?:          #roleReference
		PrepositionalPhrases?: #prepPhrases
	})])
}
3: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:337:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-1.0.cue:421:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:421:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-1.0.cue:421:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-1.2.cue:45:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:45:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:51:5: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		float: {0, 1}
		list: {0, 1}
		struct: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-1.2.cue:80:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:80:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:82:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-1.2.cue:88:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:88:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:93:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:98:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-1.2.cue:164:2: #entity.Binding
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:80:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:82:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:88:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:93:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:98:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:227:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:232:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:241:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:247:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-1.2.cue:227:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:227:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:232:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-1.2.cue:241:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:241:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:247:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:58: {
	Adjective!: matchN(1, [close({
		Subject!:              #roleReference
		Adjectives!:           #terms
		Antonyms?:             #terms
		Measurement?:          #roleReference
		PrepositionalPhrases?: #prepPhrases
	}), close({
		Subject!:              #roleReference
		Antonyms!:             #terms
		Measurement?:          #roleReference
		PrepositionalPhrases?: #prepPhrases
	})])
}
3: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:346:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-1.2.cue:430:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:430:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-1.2.cue:430:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-2.0.cue:46:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:46:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:52:5: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		float: {0, 1}
		bytes: {0, 1}
		list: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		string: {0, 1}
		struct: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-2.0.cue:78:2: #bindingEntityDefinition.Binding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:86:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:88:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:94:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:99:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:104:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:262:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:267:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:276:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:282:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-2.0.cue:86:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:86:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:88:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-2.0.cue:94:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:94:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:99:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:104:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-2.0.cue:78:2: #entity.Definition.Binding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:86:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:88:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:94:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:99:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:104:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:262:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:267:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:276:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:282:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-2.0.cue:78:2: #entityDefinition.Binding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:86:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:88:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:94:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:99:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:104:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:262:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:267:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:276:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:282:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-2.0.cue:195:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:195:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:195:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-2.0.cue:262:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:262:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:267:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-2.0.cue:276:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:276:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:282:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:58: {
	Adjective!: matchN(1, [close({
		Subject!:              #roleReference
		Adjectives!:           #terms
		Antonyms?:             #terms
		Measurement?:          #roleReference
		PrepositionalPhrases?: #prepPhrases
	}), close({
		Subject!:              #roleReference
		Antonyms!:             #terms
		Measurement?:          #roleReference
		PrepositionalPhrases?: #prepPhrases
	})])
}
3: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:381:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-2.0.cue:471:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:471:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-2.0.cue:471:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-3.0.cue:46:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:46:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:46:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		bool: {0, 1}
		int: {0, 1}
		float: {0, 1}
		string: {0, 1}
		struct: {0, 1}
		bytes: {0, 1}
		list: {0, 1}
		null: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:89:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:89:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:91:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:97:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:97:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:102:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:107:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:189:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:89:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:91:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:97:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:102:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:107:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:272:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:277:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:286:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:292:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-3.0.cue:192:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:192:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:192:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		list: {0}
		struct: {0}
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:198:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:198:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:198:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-3.0.cue:272:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:272:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:277:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:286:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:286:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:292:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:391:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		bool: {2}
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-3.0.cue:484:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:484:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.0.cue:484:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-3.1.cue:46:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:46:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:46:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		struct: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		float: {0, 1}
		list: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:89:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:89:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:91:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:97:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:97:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:102:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:107:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:193:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:89:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:91:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:97:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:102:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:107:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:276:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:281:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:290:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:296:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-3.1.cue:196:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:196:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:196:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:202:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:202:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:202:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-3.1.cue:276:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:276:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:281:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:290:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:290:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:296:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:395:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-3.1.cue:488:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:488:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.1.cue:488:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-3.2.cue:47:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:47:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:47:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		float: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		list: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:100:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:100:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:102:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:108:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:108:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:113:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:118:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:204:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:100:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:102:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:108:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:113:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:118:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:287:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:292:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:301:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:307:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-3.2.cue:207:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:207:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:207:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:213:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:213:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:213:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-3.2.cue:287:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:287:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:292:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:301:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:301:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:307:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:406:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
		float: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-3.2.cue:499:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:499:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.2.cue:499:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-3.3.cue:47:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:47:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:47:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		bool: {0, 1}
		float: {0, 1}
		string: {0, 1}
		list: {0, 1}
		int: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
		null: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:100:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:100:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:102:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:108:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:108:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:113:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:118:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:205:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:100:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:102:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:108:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:113:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:118:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:291:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:296:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:305:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:311:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-3.3.cue:208:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:208:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:208:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
		null: {0}
		bool: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:217:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:217:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:217:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-3.3.cue:291:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:291:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:296:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:305:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:305:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:311:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:410:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-3.3.cue:503:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:503:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.3.cue:503:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-3.4.cue:47:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:47:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:47:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		null: {0, 1}
		float: {0, 1}
		list: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:64:1: #adverbPhrase
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:64:27: {
	Adverbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:64:50: {
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Adverbs
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Adverbs {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adverbs) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:120:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:120:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:122:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:128:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:128:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:133:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:138:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:227:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:120:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:122:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:128:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:133:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:138:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:319:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:324:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:333:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:339:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-3.4.cue:230:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:230:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:230:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:239:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:239:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:239:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-3.4.cue:319:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:319:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:324:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:333:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:333:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:339:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:440:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		bool: {2}
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-3.4.cue:539:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:539:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.4.cue:539:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-3.5.cue:47:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:47:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:47:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		bool: {0, 1}
		string: {0, 1}
		struct: {0, 1}
		null: {0, 1}
		int: {0, 1}
		float: {0, 1}
		bytes: {0, 1}
		list: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:64:1: #adverbPhrase
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:64:27: {
	Adverbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:64:50: {
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Adverbs
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Adverbs {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adverbs) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:125:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:125:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:127:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:133:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:133:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:138:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:143:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:232:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:125:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:127:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:133:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:138:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:143:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:324:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:329:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:338:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:344:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-3.5.cue:235:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:235:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:235:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		struct: {0}
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:244:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:244:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:244:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-3.5.cue:324:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:324:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:329:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:338:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:338:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:344:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:445:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-3.5.cue:548:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:548:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-3.5.cue:548:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-4.0.cue:44:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:44:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:44:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		list: {0, 1}
		struct: {0, 1}
		float: {0, 1}
		bytes: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		string: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:61:1: #adverbPhrase
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:61:27: {
	Adverbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:61:50: {
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Adverbs
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Adverbs {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adverbs) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:122:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:122:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:124:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:130:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:130:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:135:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:140:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:240:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:122:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:124:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:130:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:135:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:140:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:332:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:337:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:346:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:352:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-4.0.cue:243:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:243:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:243:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:252:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:252:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:252:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-4.0.cue:332:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:332:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:337:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:346:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:346:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:352:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:453:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		float: {2}
		string: {2}
		bytes: {2}
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-4.0.cue:556:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:556:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-4.0.cue:556:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/lsdlschema-4.1.cue:44:1: #adjectivePhrasingProperties
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:44:42: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Adjectives!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:44:70: {
	Subject!: matchN(1, [#identifier, #fullRoleReference])
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Subject
	values:
	kinds:
		null: {0, 1}
		bool: {0, 1}
		float: {0, 1}
		string: {0, 1}
		list: {0, 1}
		int: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
	----- PATH Adjectives
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Subject {}; possible {0, 1}
	----- PATH Adjectives {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjectives) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:61:1: #adverbPhrase
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:61:27: {
	Adverbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:61:50: {
	Antonyms!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
}
discriminate {0, 1} {
	----- PATH Adverbs
	values:
	kinds:
		list: {0}
	----- PATH Antonyms
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Adverbs {1}; possible {0, 1}
	it's possible!
	----- PATH Antonyms {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adverbs) -> {1}
	notPresent(Antonyms) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:123:1: #conceptualEntityBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:123:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:125:5: {
	ConceptualEntity!: string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:131:1: #conceptualPropertyBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:131:40: {
	Table!:  string
	Column!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:136:5: {
	Table!:   string
	Measure!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:141:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
discriminate {0, 1, 2} {
	----- PATH Table
	values:
	kinds:
		string: {0, 1}
	----- PATH Column
	values:
	kinds:
		string: {0}
	----- PATH Measure
	values:
	kinds:
		string: {1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {2}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH Table {2}; possible {0, 1, 2}
	----- PATH Column {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH Measure {0, 2}; possible {1, 2}
	it's possible!
	----- PATH ConceptualEntity {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Column) -> {1, 2}
	notPresent(ConceptualEntity) -> {0, 1}
	notPresent(Measure) -> {0, 2}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:241:1: #entityBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:123:38: {
	Table!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:125:5: {
	ConceptualEntity!: string
}
2: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:131:40: {
	Table!:  string
	Column!: string
}
3: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:136:5: {
	Table!:   string
	Measure!: string
}
4: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:141:5: {
	ConceptualEntity!:   string
	ConceptualProperty!: string
}
5: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:333:31: {
	Table!:     string
	Hierarchy!: string
}
6: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:338:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
7: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:347:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
8: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:353:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8} {
	----- PATH Table
	values:
	kinds:
		string: {0, 2, 3, 5, 7}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1, 4, 6, 8}
	----- PATH Column
	values:
	kinds:
		string: {2}
	----- PATH Measure
	values:
	kinds:
		string: {3}
	----- PATH ConceptualProperty
	values:
	kinds:
		string: {4}
	----- PATH Hierarchy
	values:
	kinds:
		string: {5, 6, 7, 8}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {7, 8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Table {1, 4, 6, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH ConceptualEntity {0, 2, 3, 5, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	----- PATH Column {0, 1, 3, 4, 5, 6, 7, 8}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Measure {0, 1, 2, 4, 5, 6, 7, 8}; possible {0, 1, 3, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH ConceptualProperty {0, 1, 2, 3, 5, 6, 7, 8}; possible {0, 1, 4, 5, 6, 7, 8}
	it's possible!
	----- PATH Hierarchy {0, 1, 2, 3, 4}; possible {0, 1, 5, 6, 7, 8}
	----- PATH HierarchyLevel {0, 1, 2, 3, 4, 5, 6}; possible {0, 1, 5, 6, 7, 8}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8})

./schemastore/src/schemas/json/lsdlschema-4.1.cue:244:1: #entityDefinition
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:244:31: {
	Binding!: matchN(1, [#conceptualEntityBinding, #conceptualPropertyBinding, #hierarchyBinding, #hierarchyLevelBinding])
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:244:57: {
	Text!: strings.MinRunes(1)
}
discriminate {0, 1} {
	----- PATH Binding
	values:
	kinds:
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
		null: {0}
	----- PATH Text
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Binding {1}; possible {0, 1}
	it's possible!
	----- PATH Text {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Binding) -> {1}
	notPresent(Text) -> {0}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:253:1: #example
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:253:22: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:253:39: #fullExample
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/lsdlschema-4.1.cue:333:1: #hierarchyBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:333:31: {
	Table!:     string
	Hierarchy!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:338:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:347:1: #hierarchyLevelBinding
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:347:36: {
	Table!:          string
	Hierarchy!:      string
	HierarchyLevel!: string
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:353:5: {
	ConceptualEntity!: string
	Hierarchy!:        string
	HierarchyLevel!:   string
}
discriminate {0, 1} {
	----- PATH Table
	values:
	kinds:
		string: {0}
	----- PATH Hierarchy
	values:
	kinds:
		string: {0, 1}
	----- PATH HierarchyLevel
	values:
	kinds:
		string: {0, 1}
	----- PATH ConceptualEntity
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH Table {1}; possible {0, 1}
	it's possible!
	----- PATH Hierarchy {}; possible {1}
	----- PATH HierarchyLevel {}; possible {1}
	----- PATH ConceptualEntity {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(ConceptualEntity) -> {0}
	notPresent(Table) -> {1}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:1: #phrasing
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:23: {
	Attribute!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:43: {
	Name!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Name!: matchN(1, [#identifier, #fullRoleReference])
	}
}
2: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:58: {
	Adjective!: matchN(1, [#adjectivePhrasingProperty, #antonymPhrasingProperty])
}
3: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:78: {
	DynamicAdjective!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Adjective!: matchN(1, [#identifier, #fullRoleReference])
	}
}
4: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:105: {
	Noun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Nouns!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
5: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:120: {
	DynamicNoun!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Noun!: matchN(1, [#identifier, #fullRoleReference])
	}
}
6: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:142: {
	Preposition!: {
		Subject!: matchN(1, [#identifier, #fullRoleReference])
		Prepositions!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
		Object!: matchN(1, [#identifier, #fullRoleReference])
	}
}
7: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:454:164: {
	Verb!: {
		Verbs!: [matchN(1, [#nonEmptyString, #fullTerm]), ...]
	}
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	----- PATH Attribute
	values:
	kinds:
		struct: {0}
	----- PATH Name
	values:
	kinds:
		struct: {1}
	----- PATH Adjective
	values:
	kinds:
		list: {2}
		struct: {2}
		null: {2}
		bool: {2}
		int: {2}
		float: {2}
		string: {2}
		bytes: {2}
	----- PATH DynamicAdjective
	values:
	kinds:
		struct: {3}
	----- PATH Noun
	values:
	kinds:
		struct: {4}
	----- PATH DynamicNoun
	values:
	kinds:
		struct: {5}
	----- PATH Preposition
	values:
	kinds:
		struct: {6}
	----- PATH Verb
	values:
	kinds:
		struct: {7}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
	----- PATH Attribute {1, 2, 3, 4, 5, 6, 7}; possible {0, 1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Name {0, 2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH Adjective {0, 1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
	it's possible!
	----- PATH DynamicAdjective {0, 1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
	it's possible!
	----- PATH Noun {0, 1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
	it's possible!
	----- PATH DynamicNoun {0, 1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
	it's possible!
	----- PATH Preposition {0, 1, 2, 3, 4, 5, 7}; possible {6, 7}
	it's possible!
	----- PATH Verb {0, 1, 2, 3, 4, 5, 6}; possible {7}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(Adjective) -> {0, 1, 3, 4, 5, 6, 7}
	notPresent(Attribute) -> {1, 2, 3, 4, 5, 6, 7}
	notPresent(DynamicAdjective) -> {0, 1, 2, 4, 5, 6, 7}
	notPresent(DynamicNoun) -> {0, 1, 2, 3, 4, 6, 7}
	notPresent(Name) -> {0, 2, 3, 4, 5, 6, 7}
	notPresent(Noun) -> {0, 1, 2, 3, 5, 6, 7}
	notPresent(Preposition) -> {0, 1, 2, 3, 4, 5, 7}
	notPresent(Verb) -> {0, 1, 2, 3, 4, 5, 6}
}

./schemastore/src/schemas/json/lsdlschema-4.1.cue:557:1: #term
0: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:557:19: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/lsdlschema-4.1.cue:557:36: #fullTerm
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/maturin.cue:126:1: #PlatformTag
0: ./schemastore/src/schemas/json/maturin.cue:126:26: {
	Manylinux!: {
		x!: int & >=0.0
		y!: int & >=0.0
	}
}
1: ./schemastore/src/schemas/json/maturin.cue:135:5: {
	Musllinux!: {
		x!: int & >=0.0
		y!: int & >=0.0
	}
}
2: ./schemastore/src/schemas/json/maturin.cue:144:5: "Linux"
discriminate {0, 1, 2} {
	kind struct: {0, 1}
	discriminate {0, 1} {
		----- PATH Manylinux
		values:
		kinds:
			struct: {0}
		----- PATH Musllinux
		values:
		kinds:
			struct: {1}
		no pure discriminator found; trying existence checks; selected {0, 1}
		----- PATH Manylinux {1}; possible {0, 1}
		it's possible!
		----- PATH Musllinux {0}; possible {1}
		it's possible!
	} -> *cuediscrim.FieldAbsenceNode
	kind string: {2}
	discriminate {2} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({2})
case struct:
	allOf {
		notPresent(Manylinux) -> {1}
		notPresent(Musllinux) -> {0}
	}
}
./schemastore/src/schemas/json/mongodb-atlas-search-index-definition.cue:39:2: storedSource
0: ./schemastore/src/schemas/json/mongodb-atlas-search-index-definition.cue:39:28: bool
1: ./schemastore/src/schemas/json/mongodb-atlas-search-index-definition.cue:39:34: matchN(>=1, [close({
	include!: [...string]
	exclude?: [...string]
}), close({
	include?: [...string]
	exclude!: [...string]
})])
discriminate {0, 1} {
	kind list: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind struct: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind bool: {0, 1}
	kind null: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind int: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind float: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind string: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
	kind bytes: {1}
	discriminate {1} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({1})
case bool:
	choose({0, 1})
case int:
	choose({1})
case float:
	choose({1})
case string:
	choose({1})
case bytes:
	choose({1})
case list:
	choose({1})
case struct:
	choose({1})
}

./schemastore/src/schemas/json/mongodb-atlas-search-index-definition.cue:85:1: #Mappings
0: ./schemastore/src/schemas/json/mongodb-atlas-search-index-definition.cue:85:23: {}
1: ./schemastore/src/schemas/json/mongodb-atlas-search-index-definition.cue:87:5: {
	fields!: {}
}
discriminate {0, 1} {
	----- PATH fields
	values:
	kinds:
		struct: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH fields {0}; possible {0, 1}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/partial-poe.cue:176:1: #one_of_tasks
0: ./schemastore/src/schemas/json/partial-poe.cue:176:27: string
1: ./schemastore/src/schemas/json/partial-poe.cue:176:35: {
	cmd!: string
}
2: ./schemastore/src/schemas/json/partial-poe.cue:176:46: {
	script!: string
}
3: ./schemastore/src/schemas/json/partial-poe.cue:176:60: {
	shell!: string
}
4: ./schemastore/src/schemas/json/partial-poe.cue:176:73: {
	sequence!: [...]
}
5: ./schemastore/src/schemas/json/partial-poe.cue:176:89: {
	expr!: string
}
6: ./schemastore/src/schemas/json/partial-poe.cue:176:101: {
	control!: matchN(1, [string, #cmd_task, #script_task, #shell_task, #sequence_task, #expr_task, #switch_task, #ref_task])
	switch!: [...]
}
7: ./schemastore/src/schemas/json/partial-poe.cue:176:115: {
	ref!: string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 2, 3, 4, 5, 6, 7}
	discriminate {1, 2, 3, 4, 5, 6, 7} {
		----- PATH cmd
		values:
		kinds:
			string: {1}
		----- PATH script
		values:
		kinds:
			string: {2}
		----- PATH shell
		values:
		kinds:
			string: {3}
		----- PATH sequence
		values:
		kinds:
			list: {4}
		----- PATH expr
		values:
		kinds:
			string: {5}
		----- PATH control
		values:
		kinds:
			float: {6}
			string: {6}
			bytes: {6}
			list: {6}
			struct: {6}
			null: {6}
			bool: {6}
			int: {6}
		----- PATH switch
		values:
		kinds:
			list: {6}
		----- PATH ref
		values:
		kinds:
			string: {7}
		no pure discriminator found; trying existence checks; selected {1, 2, 3, 4, 5, 6, 7}
		----- PATH cmd {2, 3, 4, 5, 6, 7}; possible {1, 2, 3, 4, 5, 6, 7}
		it's possible!
		----- PATH script {1, 3, 4, 5, 6, 7}; possible {2, 3, 4, 5, 6, 7}
		it's possible!
		----- PATH shell {1, 2, 4, 5, 6, 7}; possible {3, 4, 5, 6, 7}
		it's possible!
		----- PATH sequence {1, 2, 3, 5, 6, 7}; possible {4, 5, 6, 7}
		it's possible!
		----- PATH expr {1, 2, 3, 4, 6, 7}; possible {5, 6, 7}
		it's possible!
		----- PATH control {1, 2, 3, 4, 5, 7}; possible {6, 7}
		it's possible!
		----- PATH switch {1, 2, 3, 4, 5, 7}; possible {7}
		it's possible!
		nothing removed
		----- PATH ref {1, 2, 3, 4, 5, 6}; possible {7}
		it's possible!
	} -> *cuediscrim.FieldAbsenceNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({0})
case struct:
	allOf {
		notPresent(cmd) -> {2, 3, 4, 5, 6, 7}
		notPresent(control) -> {1, 2, 3, 4, 5, 7}
		notPresent(expr) -> {1, 2, 3, 4, 6, 7}
		notPresent(ref) -> {1, 2, 3, 4, 5, 6}
		notPresent(script) -> {1, 3, 4, 5, 6, 7}
		notPresent(sequence) -> {1, 2, 3, 5, 6, 7}
		notPresent(shell) -> {1, 2, 4, 5, 6, 7}
	}
}
./schemastore/src/schemas/json/partial-poetry.cue:156:4: #."poetry-dependency-any"
0: ./schemastore/src/schemas/json/partial-poetry.cue:156:40: string
1: ./schemastore/src/schemas/json/partial-poetry.cue:156:63: {
	version!: string
}
2: ./schemastore/src/schemas/json/partial-poetry.cue:156:91: {
	git!: matchN(>=1, [net.AbsURL, =~"^([A-Za-z0-9\\-]+@|https://|http://)[A-Za-z][A-Za-z0-9+.-]*(:|/)[A-Za-z0-9\\-\\.]+(/[A-Za-z0-9\\-_\\.]+)+\\.git$"])
}
3: ./schemastore/src/schemas/json/partial-poetry.cue:156:118: {
	file!: string
}
4: ./schemastore/src/schemas/json/partial-poetry.cue:156:146: {
	path!: string
}
5: ./schemastore/src/schemas/json/partial-poetry.cue:156:174: {
	url!: string
}
6: ./schemastore/src/schemas/json/partial-poetry.cue:156:201: [matchN(1, [#."poetry-dependency", #."poetry-long-dependency", #."poetry-git-dependency", #."poetry-file-dependency", #."poetry-path-dependency", #."poetry-url-dependency"]), ...]
discriminate {0, 1, 2, 3, 4, 5, 6} {
	kind list: {6}
	discriminate {6} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 2, 3, 4, 5}
	discriminate {1, 2, 3, 4, 5} {
		----- PATH version
		values:
		kinds:
			string: {1}
		----- PATH git
		values:
		kinds:
			string: {2}
			bytes: {2}
			list: {2}
			struct: {2}
			null: {2}
			bool: {2}
			int: {2}
			float: {2}
		----- PATH file
		values:
		kinds:
			string: {3}
		----- PATH path
		values:
		kinds:
			string: {4}
		----- PATH url
		values:
		kinds:
			string: {5}
		no pure discriminator found; trying existence checks; selected {1, 2, 3, 4, 5}
		----- PATH version {2, 3, 4, 5}; possible {1, 2, 3, 4, 5}
		it's possible!
		----- PATH git {1, 3, 4, 5}; possible {2, 3, 4, 5}
		it's possible!
		----- PATH file {1, 2, 4, 5}; possible {3, 4, 5}
		it's possible!
		----- PATH path {1, 2, 3, 5}; possible {4, 5}
		it's possible!
		----- PATH url {1, 2, 3, 4}; possible {5}
		it's possible!
	} -> *cuediscrim.FieldAbsenceNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({0})
case list:
	choose({6})
case struct:
	allOf {
		notPresent(file) -> {1, 2, 4, 5}
		notPresent(git) -> {1, 3, 4, 5}
		notPresent(path) -> {1, 2, 3, 5}
		notPresent(url) -> {1, 2, 3, 4}
		notPresent(version) -> {2, 3, 4, 5}
	}
}

./schemastore/src/schemas/json/partial-poetry.cue:333:4: #."poetry-script-table"
0: ./schemastore/src/schemas/json/partial-poetry.cue:333:38: {}
1: ./schemastore/src/schemas/json/partial-poetry.cue:335:4: {
	reference!: string
	type!:      "file" | "console"
}
discriminate {0, 1} {
	----- PATH reference
	values:
	kinds:
		string: {1}
	----- PATH type
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH reference {0}; possible {0, 1}
	it's possible!
	----- PATH type {0}; possible {0}
	it's possible!
	nothing removed
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/partial-setuptools.cue:144:3: dynamic.version
0: ./schemastore/src/schemas/json/partial-setuptools.cue:144:24: {
	attr!: string
}
1: ./schemastore/src/schemas/json/partial-setuptools.cue:144:44: {
	file!: matchN(1, [string, [...string]])
}
discriminate {0, 1} {
	----- PATH attr
	values:
	kinds:
		string: {0}
	----- PATH file
	values:
	kinds:
		null: {1}
		bool: {1}
		int: {1}
		float: {1}
		string: {1}
		bytes: {1}
		list: {1}
		struct: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH attr {1}; possible {0, 1}
	it's possible!
	----- PATH file {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(attr) -> {1}
	notPresent(file) -> {0}
}
./schemastore/src/schemas/json/pubspec.cue:65:1: publish_to
0: ./schemastore/src/schemas/json/pubspec.cue:65:25: net.AbsURL()
1: ./schemastore/src/schemas/json/pubspec.cue:65:37: "none"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/pubspec.cue:193:1: #dependency
0: ./schemastore/src/schemas/json/pubspec.cue:226:32: "any"
1: ./schemastore/src/schemas/json/pubspec.cue:226:40: ""
2: ./schemastore/src/schemas/json/pubspec.cue:226:44: =~"^\\d+\\.\\d+\\.\\d+(?:[+-]\\S+)?$"
3: ./schemastore/src/schemas/json/pubspec.cue:226:54: =~"^(?:(?:>=|>|<=|<)\\d+\\.\\d+\\.\\d+(?:[+-]\\S+)?\\s*)+$"
4: ./schemastore/src/schemas/json/pubspec.cue:226:115: =~"^\\^\\d+\\.\\d+\\.\\d+(?:[+-]\\S+)?$"
5: ./schemastore/src/schemas/json/pubspec.cue:193:45: null
6: ./schemastore/src/schemas/json/pubspec.cue:193:51: {
	sdk!: string
}
7: ./schemastore/src/schemas/json/pubspec.cue:197:5: {
	hosted!: matchN(1, [net.AbsURL, {
		name?: string
		url!:  net.AbsURL
		...
	}])
}
8: ./schemastore/src/schemas/json/pubspec.cue:206:5: {
	git!: matchN(1, [string, {
		url?:  string
		path?: string
		ref?:  string
		...
	}])
}
9: ./schemastore/src/schemas/json/pubspec.cue:219:5: {}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} {
	----- PATH sdk
	values:
	kinds:
		string: {6}
	----- PATH hosted
	values:
	kinds:
		bytes: {7}
		list: {7}
		struct: {7}
		null: {7}
		bool: {7}
		int: {7}
		float: {7}
		string: {7}
	----- PATH git
	values:
	kinds:
		null: {8}
		bool: {8}
		int: {8}
		float: {8}
		string: {8}
		bytes: {8}
		list: {8}
		struct: {8}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	----- PATH sdk {0, 1, 2, 3, 4, 5, 7, 8, 9}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	it's possible!
	----- PATH hosted {0, 1, 2, 3, 4, 5, 6, 8, 9}; possible {0, 1, 2, 3, 4, 5, 7, 8, 9}
	it's possible!
	----- PATH git {0, 1, 2, 3, 4, 5, 6, 7, 9}; possible {0, 1, 2, 3, 4, 5, 8, 9}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})

./schemastore/src/schemas/json/pubspec.cue:226:1: #versionConstraint
0: ./schemastore/src/schemas/json/pubspec.cue:226:32: "any"
1: ./schemastore/src/schemas/json/pubspec.cue:226:40: ""
2: ./schemastore/src/schemas/json/pubspec.cue:226:44: =~"^\\d+\\.\\d+\\.\\d+(?:[+-]\\S+)?$"
3: ./schemastore/src/schemas/json/pubspec.cue:226:54: =~"^(?:(?:>=|>|<=|<)\\d+\\.\\d+\\.\\d+(?:[+-]\\S+)?\\s*)+$"
4: ./schemastore/src/schemas/json/pubspec.cue:226:115: =~"^\\^\\d+\\.\\d+\\.\\d+(?:[+-]\\S+)?$"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})
./schemastore/src/schemas/json/putout.cue:38:1: #rule
0: ./schemastore/src/schemas/json/putout.cue:38:19: "on"
1: ./schemastore/src/schemas/json/putout.cue:38:26: "off"
2: ./schemastore/src/schemas/json/putout.cue:38:33: ["on" | "off", {}]
3: ./schemastore/src/schemas/json/putout.cue:40:19: ["on" | "off", string, {}]
4: ./schemastore/src/schemas/json/putout.cue:42:22: ["on" | "off", string]
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})
./schemastore/src/schemas/json/servicehub.service.schema.cue:23:1: entryPoint
0: ./schemastore/src/schemas/json/servicehub.service.schema.cue:23:25: {
	assemblyPath!:  string
	fullClassName!: string
}
1: ./schemastore/src/schemas/json/servicehub.service.schema.cue:43:5: {
	scriptPath!:          string
	constructorFunction!: string
}
discriminate {0, 1} {
	----- PATH assemblyPath
	values:
	kinds:
		string: {0}
	----- PATH fullClassName
	values:
	kinds:
		string: {0}
	----- PATH scriptPath
	values:
	kinds:
		string: {1}
	----- PATH constructorFunction
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH assemblyPath {1}; possible {0, 1}
	it's possible!
	----- PATH fullClassName {1}; possible {1}
	it's possible!
	nothing removed
	----- PATH scriptPath {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(assemblyPath) -> {1}
	notPresent(scriptPath) -> {0}
}
./schemastore/src/schemas/json/tldr.cue:4:2: platform
0: ./schemastore/src/schemas/json/tldr.cue:4:24: "linux"
1: ./schemastore/src/schemas/json/tldr.cue:4:33: string
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/traefik-v2-file-provider.cue:698:1: #httpMiddleware
0: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:698:29: {}
1: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:700:5: {}
2: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:702:5: {}
3: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:704:5: {}
4: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:706:5: {}
5: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:708:5: {}
6: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:710:5: {}
7: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:712:5: {}
8: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:714:5: {}
9: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:716:5: {}
10: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:718:5: {}
11: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:720:5: {}
12: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:722:5: {}
13: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:724:5: {}
14: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:726:5: {}
15: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:728:5: {}
16: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:730:5: {}
17: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:732:5: {}
18: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:734:5: {}
19: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:736:5: {}
20: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:738:5: {}
21: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:740:5: {}
22: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:742:5: {}
23: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:744:5: {}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23})

./schemastore/src/schemas/json/traefik-v2-file-provider.cue:841:1: #httpService
0: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:841:26: {}
1: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:843:5: {}
2: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:845:5: {}
3: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:847:5: {}
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/traefik-v2-file-provider.cue:1284:1: #tcpService
0: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:1284:25: {}
1: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:1286:5: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/traefik-v2-file-provider.cue:1321:1: #udpService
0: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:1321:25: {}
1: ./schemastore/src/schemas/json/traefik-v2-file-provider.cue:1323:5: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/traefik-v3-file-provider.cue:739:1: #httpMiddleware
0: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:739:29: {}
1: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:741:5: {}
2: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:743:5: {}
3: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:745:5: {}
4: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:747:5: {}
5: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:749:5: {}
6: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:751:5: {}
7: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:753:5: {}
8: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:755:5: {}
9: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:757:5: {}
10: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:759:5: {}
11: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:761:5: {}
12: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:763:5: {}
13: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:765:5: {}
14: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:767:5: {}
15: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:769:5: {}
16: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:771:5: {}
17: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:773:5: {}
18: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:775:5: {}
19: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:777:5: {}
20: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:779:5: {}
21: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:781:5: {}
22: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:783:5: {}
23: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:785:5: {}
24: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:787:5: {}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24})

./schemastore/src/schemas/json/traefik-v3-file-provider.cue:891:1: #httpService
0: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:891:26: {}
1: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:893:5: {}
2: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:895:5: {}
3: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:897:5: {}
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/traefik-v3-file-provider.cue:1346:1: #tcpService
0: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:1346:25: {}
1: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:1348:5: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/traefik-v3-file-provider.cue:1383:1: #udpService
0: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:1383:25: {}
1: ./schemastore/src/schemas/json/traefik-v3-file-provider.cue:1385:5: {}
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/travis.cue:13:3: notifications.webhooks
0: ./schemastore/src/schemas/json/travis.cue:498:35: string
1: ./schemastore/src/schemas/json/travis.cue:498:43: {}
2: ./schemastore/src/schemas/json/travis.cue:502:95: [matchN(1, [string, close({
	secure?: string
})]), ...]
3: ./schemastore/src/schemas/json/travis.cue:13:85: bool
4: ./schemastore/src/schemas/json/travis.cue:13:91: {}
5: ./schemastore/src/schemas/json/travis.cue:13:142: [{}, ...{}]
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/travis.cue:14:3: notifications.slack
0: ./schemastore/src/schemas/json/travis.cue:511:24: =~".+:.+(#.+)?"
1: ./schemastore/src/schemas/json/travis.cue:511:41: {}
2: ./schemastore/src/schemas/json/travis.cue:14:34: bool
3: ./schemastore/src/schemas/json/travis.cue:14:40: {}
4: ./schemastore/src/schemas/json/travis.cue:14:88: [{}, ...{}]
discriminate {0, 1, 2, 3, 4} {
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 3}
	discriminate {1, 3} {
		no pure discriminator found; trying existence checks; selected {1, 3}
	} -> *cuediscrim.LeafNode
	kind bool: {2}
	discriminate {2} {
	} -> *cuediscrim.LeafNode
	kind list: {4}
	discriminate {4} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case bool:
	choose({2})
case string:
	choose({0})
case list:
	choose({4})
case struct:
	choose({1, 3})
}

./schemastore/src/schemas/json/travis.cue:15:3: notifications.email
0: ./schemastore/src/schemas/json/travis.cue:498:35: string
1: ./schemastore/src/schemas/json/travis.cue:498:43: {}
2: ./schemastore/src/schemas/json/travis.cue:502:95: [matchN(1, [string, close({
	secure?: string
})]), ...]
3: ./schemastore/src/schemas/json/travis.cue:15:82: bool
4: ./schemastore/src/schemas/json/travis.cue:15:88: {}
5: ./schemastore/src/schemas/json/travis.cue:15:136: [{}, ...{}]
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/travis.cue:16:3: notifications.irc
0: ./schemastore/src/schemas/json/travis.cue:498:35: string
1: ./schemastore/src/schemas/json/travis.cue:498:43: {}
2: ./schemastore/src/schemas/json/travis.cue:502:95: [matchN(1, [string, close({
	secure?: string
})]), ...]
3: ./schemastore/src/schemas/json/travis.cue:16:80: bool
4: ./schemastore/src/schemas/json/travis.cue:16:86: {}
5: ./schemastore/src/schemas/json/travis.cue:16:132: [{}, ...{}]
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/travis.cue:17:3: notifications.pushover
0: ./schemastore/src/schemas/json/travis.cue:488:53: strings.MinRunes(1)
1: ./schemastore/src/schemas/json/travis.cue:488:70: [...strings.MinRunes(1)]
2: ./schemastore/src/schemas/json/travis.cue:17:66: bool
3: ./schemastore/src/schemas/json/travis.cue:17:72: {}
4: ./schemastore/src/schemas/json/travis.cue:17:123: [{}, ...{}]
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/travis.cue:18:3: notifications.campfire
0: ./schemastore/src/schemas/json/travis.cue:498:35: string
1: ./schemastore/src/schemas/json/travis.cue:498:43: {}
2: ./schemastore/src/schemas/json/travis.cue:502:95: [matchN(1, [string, close({
	secure?: string
})]), ...]
3: ./schemastore/src/schemas/json/travis.cue:18:85: bool
4: ./schemastore/src/schemas/json/travis.cue:18:91: {}
5: ./schemastore/src/schemas/json/travis.cue:18:142: [{}, ...{}]
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/travis.cue:19:3: notifications.flowdock
0: ./schemastore/src/schemas/json/travis.cue:498:35: string
1: ./schemastore/src/schemas/json/travis.cue:498:43: {}
2: ./schemastore/src/schemas/json/travis.cue:19:48: bool
3: ./schemastore/src/schemas/json/travis.cue:19:54: {}
4: ./schemastore/src/schemas/json/travis.cue:19:105: [{}, ...{}]
discriminate {0, 1, 2, 3, 4} {
	kind list: {4}
	discriminate {4} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 3}
	discriminate {1, 3} {
		no pure discriminator found; trying existence checks; selected {1, 3}
	} -> *cuediscrim.LeafNode
	kind bool: {2}
	discriminate {2} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case bool:
	choose({2})
case string:
	choose({0})
case list:
	choose({4})
case struct:
	choose({1, 3})
}

./schemastore/src/schemas/json/travis.cue:20:3: notifications.hipchat
0: ./schemastore/src/schemas/json/travis.cue:498:35: string
1: ./schemastore/src/schemas/json/travis.cue:498:43: {}
2: ./schemastore/src/schemas/json/travis.cue:502:95: [matchN(1, [string, close({
	secure?: string
})]), ...]
3: ./schemastore/src/schemas/json/travis.cue:20:84: bool
4: ./schemastore/src/schemas/json/travis.cue:20:90: {}
5: ./schemastore/src/schemas/json/travis.cue:20:140: [{}, ...{}]
discriminate {0, 1, 2, 3, 4, 5} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/travis.cue:467:2: #job.env
0: ./schemastore/src/schemas/json/travis.cue:179:21: =~"[^=]+=.*"
1: ./schemastore/src/schemas/json/travis.cue:179:35: {}
2: ./schemastore/src/schemas/json/travis.cue:183:31: [...]
3: ./schemastore/src/schemas/json/travis.cue:467:29: {}
discriminate {0, 1, 2, 3} {
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 3}
	discriminate {1, 3} {
		no pure discriminator found; trying existence checks; selected {1, 3}
	} -> *cuediscrim.LeafNode
	kind list: {2}
	discriminate {2} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({0})
case list:
	choose({2})
case struct:
	choose({1, 3})
}

./schemastore/src/schemas/json/travis.cue:480:2: #job.deploy
0: ./schemastore/src/schemas/json/travis.cue:480:22: [...#deployment]
1: ./schemastore/src/schemas/json/travis.cue:480:40: #deployment
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/ubuntu-server-autoinstall.cue:34:2: autoinstall.network
0: ./schemastore/src/schemas/json/ubuntu-server-autoinstall.cue:34:23: {
	version!: 2
}
1: ./schemastore/src/schemas/json/ubuntu-server-autoinstall.cue:65:5: {
	network!: {
		version!: 2
	}
}
discriminate {0, 1} {
	----- PATH version
	values:
		2: {0}
	kinds:
	----- PATH network
	values:
	kinds:
		struct: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH version {1}; possible {0, 1}
	it's possible!
	----- PATH network {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(network) -> {0}
	notPresent(version) -> {1}
}
./schemastore/src/schemas/json/uv.cue:499:1: #ConfigSettingValue
0: ./schemastore/src/schemas/json/uv.cue:499:33: {
	String!: string
}
1: ./schemastore/src/schemas/json/uv.cue:501:5: {
	List!: [...string]
}
discriminate {0, 1} {
	----- PATH String
	values:
	kinds:
		string: {0}
	----- PATH List
	values:
	kinds:
		list: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH String {1}; possible {0, 1}
	it's possible!
	----- PATH List {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(List) -> {0}
	notPresent(String) -> {1}
}
./schemastore/src/schemas/json/uxp-manifest-5.cue:334:2: #iconDefinition.theme
0: ./schemastore/src/schemas/json/uxp-manifest-5.cue:334:21: ["lightest" | "light" | "dark" | "darkest", ..."lightest" | "light" | "dark" | "darkest"]
1: ./schemastore/src/schemas/json/uxp-manifest-5.cue:334:101: ["all"]
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/uxp-manifest-5.cue:339:2: #iconDefinition.species
0: ./schemastore/src/schemas/json/uxp-manifest-5.cue:339:23: ["generic"]
1: ./schemastore/src/schemas/json/uxp-manifest-5.cue:339:36: ["toolbar"]
2: ./schemastore/src/schemas/json/uxp-manifest-5.cue:339:49: ["pluginList"]
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:54:9: _#defs."/definitions/1b880/full"
0: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:54:47: matchN(>=1, [=~"^.*\\.[vV][cC][dD][lL]$", =~"^.*\\.[vV][cC][oO][dD][mM]$"])
1: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:54:81: [...]
discriminate {0, 1} {
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:60:2: _#defs."/definitions/4839f/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:60:27: matchN(>=1, [=~"^.*\\.[vV][sS][yY][sS][vV][aA][rR]$", =~"^.*\\.[xX][mM][lL]$"])
1: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:60:61: [...]
discriminate {0, 1} {
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:92:9: _#defs."/definitions/5e57d/full"
0: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:92:47: {
	"file-path"!:       =~"^.*\\.[Ff][Mm][Uu]$"
	"stepsize-in-sec"!: >0 & <=10000 & math.MultipleOf(0.00001)
}
1: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:96:5: {
	"file-path"!:       =~"^.*\\.[Ff][Mm][Uu]$"
	"stepsize-in-sec"!: >0 & <=10000 & math.MultipleOf(0.00001)
	"active-model-variables"!: [...string]
}
2: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.0.0.cue:101:5: {
	"file-path"!:       =~"^.*\\.[Ff][Mm][Uu]$"
	"stepsize-in-sec"!: >0 & <=10000 & math.MultipleOf(0.00001)
	"inactive-model-variables"!: [...string]
}
discriminate {0, 1, 2} {
	----- PATH file-path
	values:
	kinds:
		string: {0, 1, 2}
	----- PATH stepsize-in-sec
	values:
	kinds:
		int: {0, 1, 2}
		float: {0, 1, 2}
	----- PATH active-model-variables
	values:
	kinds:
		list: {1}
	----- PATH inactive-model-variables
	values:
	kinds:
		list: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH file-path {}; possible {0, 1, 2}
	----- PATH stepsize-in-sec {}; possible {0, 1, 2}
	----- PATH active-model-variables {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH inactive-model-variables {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:52:9: _#defs."/definitions/1b880/full"
0: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:52:47: matchN(>=1, [=~"^.*\\.[vV][cC][dD][lL]$", =~"^.*\\.[vV][cC][oO][dD][mM]$"])
1: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:52:81: [...]
discriminate {0, 1} {
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:65:2: _#defs."/definitions/4839f/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:65:27: matchN(>=1, [=~"^.*\\.[vV][sS][yY][sS][vV][aA][rR]$", =~"^.*\\.[xX][mM][lL]$"])
1: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:65:61: [...]
discriminate {0, 1} {
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:104:9: _#defs."/definitions/5e57d/full"
0: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:104:47: {
	"file-path"!:       =~"^.*\\.[Ff][Mm][Uu]$"
	"stepsize-in-sec"!: >0 & <=10000 & math.MultipleOf(0.00001)
}
1: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:108:5: {
	"file-path"!:       =~"^.*\\.[Ff][Mm][Uu]$"
	"stepsize-in-sec"!: >0 & <=10000 & math.MultipleOf(0.00001)
	"active-model-variables"!: [...string]
}
2: ./schemastore/src/schemas/json/venvironment-basic-schema-v3.2.0.cue:113:5: {
	"file-path"!:       =~"^.*\\.[Ff][Mm][Uu]$"
	"stepsize-in-sec"!: >0 & <=10000 & math.MultipleOf(0.00001)
	"inactive-model-variables"!: [...string]
}
discriminate {0, 1, 2} {
	----- PATH file-path
	values:
	kinds:
		string: {0, 1, 2}
	----- PATH stepsize-in-sec
	values:
	kinds:
		int: {0, 1, 2}
		float: {0, 1, 2}
	----- PATH active-model-variables
	values:
	kinds:
		list: {1}
	----- PATH inactive-model-variables
	values:
	kinds:
		list: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH file-path {}; possible {0, 1, 2}
	----- PATH stepsize-in-sec {}; possible {0, 1, 2}
	----- PATH active-model-variables {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH inactive-model-variables {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:652:9: _#defs."/definitions/ce2b5/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:652:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	value!: bool | number | string
}
1: ./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:656:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "int"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:662:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "uint"
}
3: ./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:668:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "string" | "path"
}
4: ./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:674:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "bool"
}
5: ./schemastore/src/schemas/json/venvironment-schema-v2.0.0.cue:680:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "float"
}
discriminate {0, 1, 2, 3, 4, 5} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2, 3, 4, 5}
	----- PATH value
	values:
	kinds:
		float: {0}
		string: {0}
		bool: {0}
		int: {0}
	----- PATH type
	values:
		"uint": {2}
		"string": {3}
		"path": {3}
		"bool": {4}
		"float": {5}
		"int": {1}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
	----- PATH name {}; possible {0, 1, 2, 3, 4, 5}
	----- PATH value {1, 2, 3, 4, 5}; possible {0, 1, 2, 3, 4, 5}
	it's possible!
	----- PATH type {0}; possible {1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})
./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:2: _#defs."/definitions/0fa26/full".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:2: _#defs."/definitions/3dd98/full"."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:2: _#defs."/definitions/9bffe/full"."global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:844:9: _#defs."/definitions/ce2b5/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:844:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	value!: bool | number | string
}
1: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:848:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "int"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:854:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "uint"
}
3: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:860:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "string" | "path"
}
4: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:866:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "bool"
}
5: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:872:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "float"
}
discriminate {0, 1, 2, 3, 4, 5} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2, 3, 4, 5}
	----- PATH value
	values:
	kinds:
		int: {0}
		float: {0}
		string: {0}
		bool: {0}
	----- PATH type
	values:
		"bool": {4}
		"float": {5}
		"int": {1}
		"uint": {2}
		"string": {3}
		"path": {3}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
	----- PATH name {}; possible {0, 1, 2, 3, 4, 5}
	----- PATH value {1, 2, 3, 4, 5}; possible {0, 1, 2, 3, 4, 5}
	it's possible!
	----- PATH type {0}; possible {1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:2: "global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.1.0.cue:255:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:66:9: _#defs."/definitions/048e3/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:66:47: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>=0 & <=10000, _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:71:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>=0 & <=10000, _#defs."/definitions/779cd/full"])
	"active-model-variables"!: [...]
}
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:77:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>=0 & <=10000, _#defs."/definitions/779cd/full"])
	"inactive-model-variables"!: [...]
}
discriminate {0, 1, 2} {
	----- PATH file-path
	values:
	kinds:
		float: {0, 1, 2}
		bytes: {0, 1, 2}
		list: {0, 1, 2}
		struct: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		int: {0, 1, 2}
		string: {0, 1, 2}
	----- PATH stepsize-in-sec
	values:
	kinds:
		int: {0, 1, 2}
		float: {0, 1, 2}
		bytes: {0, 1, 2}
		bool: {0, 1, 2}
		string: {0, 1, 2}
		list: {0, 1, 2}
		struct: {0, 1, 2}
		null: {0, 1, 2}
	----- PATH active-model-variables
	values:
	kinds:
		list: {1}
	----- PATH inactive-model-variables
	values:
	kinds:
		list: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH file-path {}; possible {0, 1, 2}
	----- PATH stepsize-in-sec {}; possible {0, 1, 2}
	----- PATH active-model-variables {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH inactive-model-variables {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:2: _#defs."/definitions/0d894/full"."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:2: _#defs."/definitions/159aa/full".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:2: _#defs."/definitions/3d295/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:2: _#defs."/definitions/3d295/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:247:2: _#defs."/definitions/3d295/full"."replay-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:247:29: "all-responses"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:247:47: "master-responses-only"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:247:73: "master-requests-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:247:98: "no-headers"
4: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:247:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:2: _#defs."/definitions/40c51/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:333:9: _#defs."/definitions/535fe/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:333:47: matchN(>=1, [=~"^.*\\.[vV][cC][dD][lL]$", =~"^.*\\.[vV][cC][oO][dD][mM]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:333:81: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:347:2: _#defs."/definitions/5b3ba/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:347:27: matchN(>=1, [=~"^.*\\.[Yy][Aa]?[Mm][Ll]$", =~"^.*\\.[xX][cC][pP][cC][fF][gG]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:347:61: [...]
discriminate {0, 1} {
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:398:9: _#defs."/definitions/6b85b/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:398:47: =~"[0-9a-fA-F][02468aceACE](:[0-9a-fA-F]{2}){5}"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:398:97: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:418:9: _#defs."/definitions/6f0a1/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:418:47: =~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:418:131: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:434:2: _#defs."/definitions/70264/full"."database-node"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:434:31: bool
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:434:37: string & matchN(0, [_#defs."/definitions/779cd/full"])
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:434:93: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:2: _#defs."/definitions/769ae/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:471:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:2: _#defs."/definitions/7bd0e/full".fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:2: _#defs."/definitions/7bd0e/full"."global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:2: _#defs."/definitions/7bd0e/full"."global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:2: _#defs."/definitions/7bd0e/full"."global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:2: _#defs."/definitions/7bd0e/full"."global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:2: _#defs."/definitions/7bd0e/full"."global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:2: _#defs."/definitions/7c80e/full"."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:2: _#defs."/definitions/7c80e/full"."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:585:9: _#defs."/definitions/85c8a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:585:47: "internal-simulator"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:585:70: "external-sil-kit"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:585:90: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:601:9: _#defs."/definitions/87cf9/local/ipv4-with-subnet"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:601:65: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-mask"!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:604:5: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-prefix-length"!: matchN(1, [int & >=0 & <=32, _#defs."/definitions/779cd/full"])
}
discriminate {0, 1} {
	----- PATH address
	values:
	kinds:
		float: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		bool: {0, 1}
		list: {0, 1}
		struct: {0, 1}
		null: {0, 1}
		int: {0, 1}
	----- PATH subnet-mask
	values:
	kinds:
		struct: {0}
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
	----- PATH subnet-prefix-length
	values:
	kinds:
		null: {1}
		bool: {1}
		int: {1}
		float: {1}
		string: {1}
		bytes: {1}
		list: {1}
		struct: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH address {}; possible {0, 1}
	----- PATH subnet-mask {1}; possible {0, 1}
	it's possible!
	----- PATH subnet-prefix-length {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(subnet-mask) -> {1}
	notPresent(subnet-prefix-length) -> {0}
}

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:2: _#defs."/definitions/896d0/full".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:2: _#defs."/definitions/896d0/full".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:2: _#defs."/definitions/896d0/full".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:2: _#defs."/definitions/896d0/full".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:2: _#defs."/definitions/896d0/full".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:2: _#defs."/definitions/8a040/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:703:9: _#defs."/definitions/8ab6a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:703:47: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:703:77: =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:2: _#defs."/definitions/b1d9c/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:2: _#defs."/definitions/b1d9c/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:833:2: _#defs."/definitions/b5d87/full".mode
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:833:20: "commander"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:833:34: "responder"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:833:47: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:853:2: _#defs."/definitions/ba2d9/full".mode
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:853:20: "iso"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:853:28: "non-iso"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:853:39: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:892:2: _#defs."/definitions/bd659/full"."capl-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:892:35: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:892:69: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:897:2: _#defs."/definitions/bd659/full"."c-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:897:32: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:897:66: [...]
discriminate {0, 1} {
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:2: _#defs."/definitions/be1e5/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:147:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:2: _#defs."/definitions/be1e5/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:676:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:995:2: _#defs."/definitions/d5013/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:995:27: matchN(>=1, [=~"^.*\\.[vV][sS][yY][sS][vV][aA][rR]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:995:61: [...]
discriminate {0, 1} {
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1017:9: _#defs."/definitions/daa86/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1017:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	value!: bool | number | string
}
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1023:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "int"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1029:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "uint"
}
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1035:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "string" | "path"
}
4: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1043:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "bool"
}
5: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1051:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "float"
}
discriminate {0, 1, 2, 3, 4, 5} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2, 3, 4, 5}
	----- PATH value
	values:
	kinds:
		int: {0}
		float: {0}
		string: {0}
		bool: {0}
	----- PATH type
	values:
		"int": {1}
		"uint": {2}
		"path": {3}
		"string": {3}
		"bool": {4}
		"float": {5}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
	----- PATH name {}; possible {0, 1, 2, 3, 4, 5}
	----- PATH value {1, 2, 3, 4, 5}; possible {0, 1, 2, 3, 4, 5}
	it's possible!
	----- PATH type {0}; possible {1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1228:9: _#defs."/definitions/eaee8/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1228:47: =~"^([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){7}|:(:[0-9A-Fa-f]{1,4}){1,7}|([0-9A-Fa-f]{1,4}:){1,7}:|::|([0-9A-Fa-f]{1,4}:){1}(:[0-9A-Fa-f]{1,4}){1,6}|([0-9A-Fa-f]{1,4}:){2}(:[0-9A-Fa-f]{1,4}){1,5}|([0-9A-Fa-f]{1,4}:){3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}){1})$"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1228:430: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:2: _#defs."/definitions/fbf90/full"."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:2: _#defs."/definitions/fbf90/full"."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:2: _#defs."/definitions/fbf90/full"."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:2: fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:119:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:2: "global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:528:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:2: "global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:536:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:2: "global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1314:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:2: "global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1319:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:2: "global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v2.2.0.cue:1323:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})
./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:20:9: _#defs."/definitions/00e8b/local/ipv4-with-subnet"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:20:65: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-mask"!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:24:5: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-prefix-length"!: matchN(1, [int & >=0 & <=32, _#defs."/definitions/779cd/full"])
}
discriminate {0, 1} {
	----- PATH address
	values:
	kinds:
		float: {0, 1}
		struct: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		list: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
	----- PATH subnet-mask
	values:
	kinds:
		struct: {0}
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
	----- PATH subnet-prefix-length
	values:
	kinds:
		int: {1}
		float: {1}
		string: {1}
		bytes: {1}
		list: {1}
		struct: {1}
		null: {1}
		bool: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH address {}; possible {0, 1}
	----- PATH subnet-mask {1}; possible {0, 1}
	it's possible!
	----- PATH subnet-prefix-length {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(subnet-mask) -> {1}
	notPresent(subnet-prefix-length) -> {0}
}

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:46:9: _#defs."/definitions/07d01/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:46:47: =~"[0-9a-fA-F][02468aceACE](:[0-9a-fA-F]{2}){5}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:46:97: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:60:2: _#defs."/definitions/0894d/full".interface
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:60:25: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:60:59: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:64:2: _#defs."/definitions/0894d/full".variant
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:64:23: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:64:57: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:70:2: _#defs."/definitions/0894d/full".language
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:70:24: =~"^[a-z]{2}[-][A-Z]{2}$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:70:51: =~"^[a-z]{2}$"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:70:67: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:2: _#defs."/definitions/0894d/full"."doip-settings"."tls-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:26: "deactivated"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:41: "routing-activation"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:63: "secure-connection-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:89: "direct-connection"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:110: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:813:2: _#defs."/definitions/0894d/full"."doip-settings"."tls-client"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:813:28: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:813:36: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:2: _#defs."/definitions/0a579/full".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:2: _#defs."/definitions/0be70/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:2: _#defs."/definitions/0be70/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:185:2: _#defs."/definitions/17563/full"."capl-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:185:35: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:185:69: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:190:2: _#defs."/definitions/17563/full"."c-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:190:32: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:190:66: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:257:2: _#defs."/definitions/2b57a/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:257:27: matchN(>=1, [=~"^.*\\.[Yy][Aa]?[Mm][Ll]$", =~"^.*\\.[xX][cC][pP][cC][fF][gG]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:257:61: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:264:9: _#defs."/definitions/2c08a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:264:47: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:269:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
	"active-model-variables"!: [...]
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:275:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
	"inactive-model-variables"!: [...]
}
discriminate {0, 1, 2} {
	----- PATH file-path
	values:
	kinds:
		int: {0, 1, 2}
		string: {0, 1, 2}
		list: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		float: {0, 1, 2}
		bytes: {0, 1, 2}
		struct: {0, 1, 2}
	----- PATH stepsize-in-sec
	values:
	kinds:
		float: {0, 1, 2}
		list: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		int: {0, 1, 2}
		string: {0, 1, 2}
		bytes: {0, 1, 2}
		struct: {0, 1, 2}
	----- PATH active-model-variables
	values:
	kinds:
		list: {1}
	----- PATH inactive-model-variables
	values:
	kinds:
		list: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH file-path {}; possible {0, 1, 2}
	----- PATH stepsize-in-sec {}; possible {0, 1, 2}
	----- PATH active-model-variables {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH inactive-model-variables {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:2: _#defs."/definitions/548bf/full".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:542:9: _#defs."/definitions/66d5a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:542:47: matchN(>=1, [=~"^.*\\.[vV][cC][dD][lL]$", =~"^.*\\.[vV][cC][oO][dD][mM]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:542:81: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:2: _#defs."/definitions/6737b/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:2: _#defs."/definitions/6737b/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:584:9: _#defs."/definitions/6f0a1/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:584:47: =~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:584:131: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:2: _#defs."/definitions/7615c/full"."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:687:2: _#defs."/definitions/81e26/full"."database-node"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:687:31: bool
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:687:37: string & matchN(0, [_#defs."/definitions/779cd/full"])
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:687:93: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:701:9: _#defs."/definitions/83eeb/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:701:47: "internal-simulator"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:701:70: "external-sil-kit"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:701:91: "external-hardware"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:701:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:733:9: _#defs."/definitions/8ab6a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:733:47: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:733:77: =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:740:2: _#defs."/definitions/8b228/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:740:27: matchN(>=1, [=~"^.*\\.[vV][sS][yY][sS][vV][aA][rR]$", =~"^.*\\.[xX][mM][lL]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:740:61: [...]
discriminate {0, 1} {
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:2: _#defs."/definitions/94efe/full"."tls-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:26: "deactivated"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:41: "routing-activation"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:63: "secure-connection-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:89: "direct-connection"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:810:110: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:813:2: _#defs."/definitions/94efe/full"."tls-client"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:813:28: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:813:36: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:2: _#defs."/definitions/9d0dc/full"."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:2: _#defs."/definitions/9d0dc/full"."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:2: _#defs."/definitions/9d0dc/full"."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:866:9: _#defs."/definitions/9d153/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:866:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	value!: bool | number | string
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:872:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "int"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:880:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "uint"
}
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:888:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "string" | "path"
}
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:898:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "bool"
}
5: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:908:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "float"
}
discriminate {0, 1, 2, 3, 4, 5} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2, 3, 4, 5}
	----- PATH value
	values:
	kinds:
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
	----- PATH type
	values:
		"uint": {2}
		"string": {3}
		"path": {3}
		"bool": {4}
		"float": {5}
		"int": {1}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
	----- PATH name {}; possible {0, 1, 2, 3, 4, 5}
	----- PATH value {1, 2, 3, 4, 5}; possible {0, 1, 2, 3, 4, 5}
	it's possible!
	----- PATH type {0}; possible {1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:2: _#defs."/definitions/9d210/full"."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:2: _#defs."/definitions/a0975/full"."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:2: _#defs."/definitions/a0975/full"."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1093:9: _#defs."/definitions/a46be/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1093:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1103:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
	"can-settings"!: _#defs."/definitions/efe85/full"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1114:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
	"can-fd-settings"!: _#defs."/definitions/7c619/full"
}
discriminate {0, 1, 2} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2}
	----- PATH database
	values:
	kinds:
		list: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		int: {0, 1, 2}
		string: {0, 1, 2}
		bytes: {0, 1, 2}
		struct: {0, 1, 2}
		float: {0, 1, 2}
	----- PATH can-settings
	values:
	kinds:
	----- PATH can-fd-settings
	values:
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH name {}; possible {0, 1, 2}
	----- PATH database {}; possible {0, 1, 2}
	----- PATH can-settings {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH can-fd-settings {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:2: _#defs."/definitions/a5af1/full".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:2: _#defs."/definitions/a5af1/full".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:2: _#defs."/definitions/a5af1/full".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:2: _#defs."/definitions/a5af1/full".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:2: _#defs."/definitions/a5af1/full".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:2: _#defs."/definitions/b2867/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:2: _#defs."/definitions/cfd6f/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:467:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:2: _#defs."/definitions/cfd6f/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1188:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1306:2: _#defs."/definitions/cfd6f/full"."replay-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1306:29: "all-responses"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1306:47: "master-responses-only"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1306:73: "master-requests-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1306:98: "no-headers"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1306:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:2: _#defs."/definitions/d035f/full".fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:2: _#defs."/definitions/d035f/full"."global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:2: _#defs."/definitions/d035f/full"."global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:2: _#defs."/definitions/d035f/full"."global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:2: _#defs."/definitions/d035f/full"."global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:2: _#defs."/definitions/d035f/full"."global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:2: _#defs."/definitions/d035f/full".logging."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:2: _#defs."/definitions/d7199/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1528:9: _#defs."/definitions/eaee8/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1528:47: =~"^([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){7}|:(:[0-9A-Fa-f]{1,4}){1,7}|([0-9A-Fa-f]{1,4}:){1,7}:|::|([0-9A-Fa-f]{1,4}:){1}(:[0-9A-Fa-f]{1,4}){1,6}|([0-9A-Fa-f]{1,4}:){2}(:[0-9A-Fa-f]{1,4}){1,5}|([0-9A-Fa-f]{1,4}:){3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}){1})$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1528:430: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:2: _#defs."/definitions/eff39/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1548:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1603:2: _#defs."/definitions/f9bcf/full".mode
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1603:20: "commander"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1603:34: "responder"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1603:47: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:2: fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:608:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:2: "global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1057:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:2: "global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:1065:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:2: "global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:845:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:2: "global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:851:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:2: "global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:855:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:2: logging."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.0.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})
./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:20:9: _#defs."/definitions/00e8b/local/ipv4-with-subnet"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:20:65: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-mask"!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:24:5: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-prefix-length"!: matchN(1, [int & >=0 & <=32, _#defs."/definitions/779cd/full"])
}
discriminate {0, 1} {
	----- PATH address
	values:
	kinds:
		string: {0, 1}
		list: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
		null: {0, 1}
		bool: {0, 1}
		int: {0, 1}
		float: {0, 1}
	----- PATH subnet-mask
	values:
	kinds:
		null: {0}
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
	----- PATH subnet-prefix-length
	values:
	kinds:
		null: {1}
		bool: {1}
		int: {1}
		float: {1}
		string: {1}
		bytes: {1}
		list: {1}
		struct: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH address {}; possible {0, 1}
	----- PATH subnet-mask {1}; possible {0, 1}
	it's possible!
	----- PATH subnet-prefix-length {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(subnet-mask) -> {1}
	notPresent(subnet-prefix-length) -> {0}
}

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:46:9: _#defs."/definitions/07d01/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:46:47: =~"[0-9a-fA-F][02468aceACE](:[0-9a-fA-F]{2}){5}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:46:97: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:60:2: _#defs."/definitions/0894d/full".interface
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:60:25: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:60:59: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:64:2: _#defs."/definitions/0894d/full".variant
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:64:23: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:64:57: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:70:2: _#defs."/definitions/0894d/full".language
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:70:24: =~"^[a-z]{2}[-][A-Z]{2}$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:70:51: =~"^[a-z]{2}$"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:70:67: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:2: _#defs."/definitions/0894d/full"."doip-settings"."tls-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:26: "deactivated"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:41: "routing-activation"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:63: "secure-connection-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:89: "direct-connection"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:110: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:836:2: _#defs."/definitions/0894d/full"."doip-settings"."tls-client"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:836:28: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:836:36: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:2: _#defs."/definitions/0a579/full".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:2: _#defs."/definitions/0be70/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:2: _#defs."/definitions/0be70/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:178:2: _#defs."/definitions/17563/full"."capl-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:178:35: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:178:69: [...]
discriminate {0, 1} {
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:183:2: _#defs."/definitions/17563/full"."c-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:183:32: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:183:66: [...]
discriminate {0, 1} {
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:245:2: _#defs."/definitions/2b57a/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:245:27: matchN(>=1, [=~"^.*\\.[Yy][Aa]?[Mm][Ll]$", =~"^.*\\.[xX][cC][pP][cC][fF][gG]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:245:61: [...]
discriminate {0, 1} {
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:252:9: _#defs."/definitions/2c08a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:252:47: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:257:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
	"active-model-variables"!: [...]
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:263:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
	"inactive-model-variables"!: [...]
}
discriminate {0, 1, 2} {
	----- PATH file-path
	values:
	kinds:
		struct: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		float: {0, 1, 2}
		bytes: {0, 1, 2}
		int: {0, 1, 2}
		string: {0, 1, 2}
		list: {0, 1, 2}
	----- PATH stepsize-in-sec
	values:
	kinds:
		float: {0, 1, 2}
		string: {0, 1, 2}
		bytes: {0, 1, 2}
		list: {0, 1, 2}
		bool: {0, 1, 2}
		struct: {0, 1, 2}
		null: {0, 1, 2}
		int: {0, 1, 2}
	----- PATH active-model-variables
	values:
	kinds:
		list: {1}
	----- PATH inactive-model-variables
	values:
	kinds:
		list: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH file-path {}; possible {0, 1, 2}
	----- PATH stepsize-in-sec {}; possible {0, 1, 2}
	----- PATH active-model-variables {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH inactive-model-variables {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:2: _#defs."/definitions/548bf/full".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:462:2: _#defs."/definitions/54ebe/full"."database-node"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:462:31: bool
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:462:37: string & matchN(0, [_#defs."/definitions/779cd/full"])
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:462:93: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:548:9: _#defs."/definitions/66d5a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:548:47: matchN(>=1, [=~"^.*\\.[vV][cC][dD][lL]$", =~"^.*\\.[vV][cC][oO][dD][mM]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:548:81: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:2: _#defs."/definitions/6737b/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:2: _#defs."/definitions/6737b/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:2: _#defs."/definitions/6e340/full".fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:2: _#defs."/definitions/6e340/full"."global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:2: _#defs."/definitions/6e340/full"."global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:2: _#defs."/definitions/6e340/full"."global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:2: _#defs."/definitions/6e340/full"."global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:2: _#defs."/definitions/6e340/full"."global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:2: _#defs."/definitions/6e340/full".logging."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:623:9: _#defs."/definitions/6f0a1/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:623:47: =~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:623:131: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:2: _#defs."/definitions/7615c/full"."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:719:9: _#defs."/definitions/83eeb/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:719:47: "internal-simulator"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:719:70: "external-sil-kit"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:719:91: "external-hardware"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:719:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:756:9: _#defs."/definitions/8ab6a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:756:47: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:756:77: =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:763:2: _#defs."/definitions/8b228/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:763:27: matchN(>=1, [=~"^.*\\.[vV][sS][yY][sS][vV][aA][rR]$", =~"^.*\\.[xX][mM][lL]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:763:61: [...]
discriminate {0, 1} {
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:2: _#defs."/definitions/94efe/full"."tls-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:26: "deactivated"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:41: "routing-activation"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:63: "secure-connection-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:89: "direct-connection"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:833:110: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:836:2: _#defs."/definitions/94efe/full"."tls-client"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:836:28: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:836:36: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:2: _#defs."/definitions/9d0dc/full"."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:2: _#defs."/definitions/9d0dc/full"."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:2: _#defs."/definitions/9d0dc/full"."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:889:9: _#defs."/definitions/9d153/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:889:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	value!: bool | number | string
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:895:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "int"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:903:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "uint"
}
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:911:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "string" | "path"
}
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:921:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "bool"
}
5: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:931:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "float"
}
discriminate {0, 1, 2, 3, 4, 5} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2, 3, 4, 5}
	----- PATH value
	values:
	kinds:
		float: {0}
		string: {0}
		bool: {0}
		int: {0}
	----- PATH type
	values:
		"uint": {2}
		"string": {3}
		"path": {3}
		"bool": {4}
		"float": {5}
		"int": {1}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
	----- PATH name {}; possible {0, 1, 2, 3, 4, 5}
	----- PATH value {1, 2, 3, 4, 5}; possible {0, 1, 2, 3, 4, 5}
	it's possible!
	----- PATH type {0}; possible {1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:2: _#defs."/definitions/9d210/full"."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:2: _#defs."/definitions/a0975/full"."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:2: _#defs."/definitions/a0975/full"."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1116:9: _#defs."/definitions/a46be/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1116:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1126:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
	"can-settings"!: _#defs."/definitions/efe85/full"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1137:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
	"can-fd-settings"!: _#defs."/definitions/7c619/full"
}
discriminate {0, 1, 2} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2}
	----- PATH database
	values:
	kinds:
		null: {0, 1, 2}
		int: {0, 1, 2}
		float: {0, 1, 2}
		list: {0, 1, 2}
		bool: {0, 1, 2}
		string: {0, 1, 2}
		bytes: {0, 1, 2}
		struct: {0, 1, 2}
	----- PATH can-settings
	values:
	kinds:
	----- PATH can-fd-settings
	values:
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH name {}; possible {0, 1, 2}
	----- PATH database {}; possible {0, 1, 2}
	----- PATH can-settings {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH can-fd-settings {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:2: _#defs."/definitions/a5af1/full".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:2: _#defs."/definitions/a5af1/full".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:2: _#defs."/definitions/a5af1/full".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:2: _#defs."/definitions/a5af1/full".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:2: _#defs."/definitions/a5af1/full".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:2: _#defs."/definitions/b2867/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:2: _#defs."/definitions/cfd6f/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:445:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:2: _#defs."/definitions/cfd6f/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1216:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1328:2: _#defs."/definitions/cfd6f/full"."replay-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1328:29: "all-responses"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1328:47: "master-responses-only"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1328:73: "master-requests-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1328:98: "no-headers"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1328:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:2: _#defs."/definitions/d7199/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1517:9: _#defs."/definitions/eaee8/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1517:47: =~"^([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){7}|:(:[0-9A-Fa-f]{1,4}){1,7}|([0-9A-Fa-f]{1,4}:){1,7}:|::|([0-9A-Fa-f]{1,4}:){1}(:[0-9A-Fa-f]{1,4}){1,6}|([0-9A-Fa-f]{1,4}:){2}(:[0-9A-Fa-f]{1,4}){1,5}|([0-9A-Fa-f]{1,4}:){3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}){1})$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1517:430: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:2: _#defs."/definitions/eff39/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1537:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1592:2: _#defs."/definitions/f9bcf/full".mode
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1592:20: "commander"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1592:34: "responder"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1592:47: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:2: fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:647:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:2: "global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1080:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:2: "global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:1088:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:2: "global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:868:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:2: "global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:874:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:2: "global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:878:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:2: logging."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.1.0.cue:81:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})
./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:2: _#defs."/definitions/00d1b/full".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:2: _#defs."/definitions/00d1b/full".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:2: _#defs."/definitions/00d1b/full".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:2: _#defs."/definitions/00d1b/full".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:2: _#defs."/definitions/00d1b/full".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:29:9: _#defs."/definitions/07d01/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:29:47: =~"[0-9a-fA-F][02468aceACE](:[0-9a-fA-F]{2}){5}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:29:97: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:2: _#defs."/definitions/09047/full"."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:2: _#defs."/definitions/09047/full"."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:2: _#defs."/definitions/0a579/full".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:2: _#defs."/definitions/0addd/full"."scheduling-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:33: "selected-scheduling"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:56: "diagnostics-only"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:76: "interleaved"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:91: "direct-sending"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:109: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:2: _#defs."/definitions/1150a/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:191:2: _#defs."/definitions/17563/full"."capl-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:191:35: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:191:69: [...]
discriminate {0, 1} {
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:196:2: _#defs."/definitions/17563/full"."c-library-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:196:32: matchN(>=1, [=~"^.*\\.[vV][mM][oO][dD][uU][lL][eE]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:196:66: [...]
discriminate {0, 1} {
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:330:2: _#defs."/definitions/2b57a/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:330:27: matchN(>=1, [=~"^.*\\.[Yy][Aa]?[Mm][Ll]$", =~"^.*\\.[xX][cC][pP][cC][fF][gG]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:330:61: [...]
discriminate {0, 1} {
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:337:9: _#defs."/definitions/2c08a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:337:47: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:342:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
	"active-model-variables"!: [...]
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:348:5: {
	"file-path"!: matchN(>=1, [=~"^.*\\.[Ff][Mm][Uu]$", string & _#defs."/definitions/779cd/full"])
	"stepsize-in-sec"!: matchN(1, [>0 & math.MultipleOf(0.00001) & <=10000, _#defs."/definitions/779cd/full"])
	"inactive-model-variables"!: [...]
}
discriminate {0, 1, 2} {
	----- PATH file-path
	values:
	kinds:
		null: {0, 1, 2}
		bool: {0, 1, 2}
		int: {0, 1, 2}
		float: {0, 1, 2}
		string: {0, 1, 2}
		bytes: {0, 1, 2}
		list: {0, 1, 2}
		struct: {0, 1, 2}
	----- PATH stepsize-in-sec
	values:
	kinds:
		string: {0, 1, 2}
		bytes: {0, 1, 2}
		list: {0, 1, 2}
		struct: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		int: {0, 1, 2}
		float: {0, 1, 2}
	----- PATH active-model-variables
	values:
	kinds:
		list: {1}
	----- PATH inactive-model-variables
	values:
	kinds:
		list: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH file-path {}; possible {0, 1, 2}
	----- PATH stepsize-in-sec {}; possible {0, 1, 2}
	----- PATH active-model-variables {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH inactive-model-variables {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:396:9: _#defs."/definitions/3666e/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:396:47: =~"^([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){7}|:(:[0-9A-Fa-f]{1,4}){1,7}|([0-9A-Fa-f]{1,4}:){1,7}:|::|([0-9A-Fa-f]{1,4}:){1}(:[0-9A-Fa-f]{1,4}){1,6}|([0-9A-Fa-f]{1,4}:){2}(:[0-9A-Fa-f]{1,4}){1,5}|([0-9A-Fa-f]{1,4}:){3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}){1})$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:396:430: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:460:2: _#defs."/definitions/46f81/full"."database-node"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:460:31: bool
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:460:37: string & matchN(0, [_#defs."/definitions/779cd/full"])
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:460:93: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:490:9: _#defs."/definitions/4dc28/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:490:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:500:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
	"can-settings"!: _#defs."/definitions/efe85/full"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:511:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
	database!: matchN(1, [=~"^[a-zA-Z_][a-zA-Z0-9_]*$", =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"])
	"can-fd-settings"!: _#defs."/definitions/7c619/full"
}
discriminate {0, 1, 2} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2}
	----- PATH database
	values:
	kinds:
		bytes: {0, 1, 2}
		struct: {0, 1, 2}
		null: {0, 1, 2}
		bool: {0, 1, 2}
		float: {0, 1, 2}
		list: {0, 1, 2}
		int: {0, 1, 2}
		string: {0, 1, 2}
	----- PATH can-settings
	values:
	kinds:
	----- PATH can-fd-settings
	values:
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH name {}; possible {0, 1, 2}
	----- PATH database {}; possible {0, 1, 2}
	----- PATH can-settings {0, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH can-fd-settings {0, 1}; possible {0, 2}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:2: _#defs."/definitions/548bf/full".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:697:2: _#defs."/definitions/5f799/full".mode
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:697:20: "commander"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:697:34: "responder"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:697:48: "commander-no-resistor"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:697:73: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:2: _#defs."/definitions/652f5/full".fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:2: _#defs."/definitions/652f5/full"."global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:2: _#defs."/definitions/652f5/full"."global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:2: _#defs."/definitions/652f5/full"."global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:2: _#defs."/definitions/652f5/full"."global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:2: _#defs."/definitions/652f5/full"."global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:2: _#defs."/definitions/652f5/full".logging."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:765:9: _#defs."/definitions/66d5a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:765:47: matchN(>=1, [=~"^.*\\.[vV][cC][dD][lL]$", =~"^.*\\.[vV][cC][oO][dD][mM]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:765:81: [...]
discriminate {0, 1} {
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:789:9: _#defs."/definitions/6dbd8/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:789:47: =~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:789:131: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:804:2: _#defs."/definitions/72fc8/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:804:27: matchN(>=1, [=~"^.*\\.[vV][mM][aA][pP]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:804:61: [...]
discriminate {0, 1} {
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:2: _#defs."/definitions/7615c/full"."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:847:2: _#defs."/definitions/78b23/full".interface
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:847:25: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:847:68: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:851:2: _#defs."/definitions/78b23/full".variant
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:851:23: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:851:66: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:857:2: _#defs."/definitions/78b23/full".language
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:857:24: =~"^[a-z]{2}[-][A-Z]{2}$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:857:51: =~"^[a-z]{2}$"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:857:67: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:2: _#defs."/definitions/78b23/full"."doip-settings"."tls-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:26: "deactivated"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:41: "routing-activation"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:63: "secure-connection-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:89: "direct-connection"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:110: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1007:2: _#defs."/definitions/78b23/full"."doip-settings"."tls-client"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1007:28: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1007:36: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1540:2: _#defs."/definitions/78b23/full"."flexray-settings"."transport-protocol-type"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1540:41: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1540:49: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:2: _#defs."/definitions/78b23/full"."lin-settings"."scheduling-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:33: "selected-scheduling"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:56: "diagnostics-only"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:76: "interleaved"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:91: "direct-sending"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:107:109: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:920:9: _#defs."/definitions/83eeb/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:920:47: "internal-simulator"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:920:70: "external-sil-kit"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:920:91: "external-hardware"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:920:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:932:9: _#defs."/definitions/8ab6a/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:932:47: =~"^[a-zA-Z_][a-zA-Z0-9_]*$"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:932:77: =~"^([a-zA-Z_][a-zA-Z0-9_]*)?\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}[a-zA-Z0-9_]*$"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:939:2: _#defs."/definitions/8b228/full"."file-path"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:939:27: matchN(>=1, [=~"^.*\\.[vV][sS][yY][sS][vV][aA][rR]$", =~"^.*\\.[xX][mM][lL]$", string & _#defs."/definitions/779cd/full"])
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:939:61: [...]
discriminate {0, 1} {
	kind bool: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind int: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind float: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind list: {0, 1}
	kind null: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind bytes: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case null:
	choose({0})
case bool:
	choose({0})
case int:
	choose({0})
case float:
	choose({0})
case string:
	choose({0})
case bytes:
	choose({0})
case list:
	choose({0, 1})
case struct:
	choose({0})
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:2: _#defs."/definitions/94efe/full"."tls-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:26: "deactivated"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:41: "routing-activation"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:63: "secure-connection-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:89: "direct-connection"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1004:110: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1007:2: _#defs."/definitions/94efe/full"."tls-client"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1007:28: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1007:36: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:2: _#defs."/definitions/9d0dc/full"."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:2: _#defs."/definitions/9d0dc/full"."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:2: _#defs."/definitions/9d0dc/full"."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1062:9: _#defs."/definitions/9d153/full"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1062:47: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	value!: bool | number | string
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1068:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "int"
}
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1076:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "uint"
}
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1084:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "string" | "path"
}
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1094:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "bool"
}
5: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1104:5: {
	name!: =~"^[a-zA-Z_][a-zA-Z0-9_]*$" & matchN(0, [null | bool | number | =~"^[cC][aA][nN][oO][eE]_.*$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][nN][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[aA][sS][sS][eE][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][oO][oO][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[bB][rR][eE][aA][kK]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][aA][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][lL][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[cC][oO][nN][tT][iI][nN][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[dD][eE][lL][eE][tT][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[eE][xX][cC][eE][pP][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][aA][lL][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][iI][nN][aA][lL][lL][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][lL][oO][aA][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[fF][rR][oO][mM]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[gG][lL][oO][bB][aA][lL]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][mM][pP][oO][rR][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][nN][tT][eE][gG][eE][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[lL][oO][nN][gG]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][nN][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[nN][oO][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[pP][aA][sS][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][aA][iI][sS][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[rR][eE][tT][uU][rR][nN]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][cC][eE][nN][aA][rR][iI][oO]_[nN][aA][mM][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][eE][lL][fF]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][tT][rR][uU][cC][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[sS][wW][iI][tT][cC][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][hH][iI][sS]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][uU][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[tT][rR][yY]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][iI][nN][tT]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[uU][nN][sS][iI][gG][nN][eE][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[vV][oO][iI][dD]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][hH][iI][lL][eE]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[wW][iI][tT][hH]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[xX][oO][rR]$" | [...] | {}]) & matchN(0, [null | bool | number | =~"^[yY][iI][eE][lL][dD]$" | [...] | {}])
	type!: "float"
}
discriminate {0, 1, 2, 3, 4, 5} {
	----- PATH name
	values:
	kinds:
		string: {0, 1, 2, 3, 4, 5}
	----- PATH value
	values:
	kinds:
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
	----- PATH type
	values:
		"path": {3}
		"bool": {4}
		"float": {5}
		"int": {1}
		"uint": {2}
		"string": {3}
	kinds:
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5}
	----- PATH name {}; possible {0, 1, 2, 3, 4, 5}
	----- PATH value {1, 2, 3, 4, 5}; possible {0, 1, 2, 3, 4, 5}
	it's possible!
	----- PATH type {0}; possible {1, 2, 3, 4, 5}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:2: _#defs."/definitions/9d210/full"."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1305:9: _#defs."/definitions/b2008/local/ipv4-with-subnet"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1305:65: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-mask"!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
}
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1309:5: {
	address!: matchN(1, [=~"((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])", string & _#defs."/definitions/779cd/full"])
	"subnet-prefix-length"!: matchN(1, [int & >=0 & <=32, _#defs."/definitions/779cd/full"])
}
discriminate {0, 1} {
	----- PATH address
	values:
	kinds:
		int: {0, 1}
		float: {0, 1}
		list: {0, 1}
		bool: {0, 1}
		string: {0, 1}
		bytes: {0, 1}
		struct: {0, 1}
		null: {0, 1}
	----- PATH subnet-mask
	values:
	kinds:
		bool: {0}
		int: {0}
		float: {0}
		string: {0}
		bytes: {0}
		list: {0}
		struct: {0}
		null: {0}
	----- PATH subnet-prefix-length
	values:
	kinds:
		string: {1}
		bytes: {1}
		list: {1}
		struct: {1}
		null: {1}
		bool: {1}
		int: {1}
		float: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH address {}; possible {0, 1}
	----- PATH subnet-mask {1}; possible {0, 1}
	it's possible!
	----- PATH subnet-prefix-length {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(subnet-mask) -> {1}
	notPresent(subnet-prefix-length) -> {0}
}

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:2: _#defs."/definitions/b28c0/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:2: _#defs."/definitions/b28c0/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:2: _#defs."/definitions/cf728/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:2: _#defs."/definitions/cf728/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:2: _#defs."/definitions/d522d/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1540:2: _#defs."/definitions/deffc/full"."transport-protocol-type"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1540:41: string
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1540:49: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:2: _#defs."/definitions/e6bf5/full"."start-timing-condition".condition
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:25: "immediately"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:40: "first-event-time"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:60: "delayed"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:565:71: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:2: _#defs."/definitions/e6bf5/full"."channel-mapping"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:129:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1617:2: _#defs."/definitions/e6bf5/full"."replay-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1617:29: "all-responses"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1617:47: "master-responses-only"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1617:73: "master-requests-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1617:98: "no-headers"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1617:112: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:2: _#defs."/definitions/eff39/full"."default-mapping"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:33: "as-in-original"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:51: "ignore-all"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1668:65: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:2: fdx."transport-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:33: "udp/ipv4"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:46: "udp/ipv6"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:59: "tcp/ipv4"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:72: "tcp/ipv6"
4: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:814:84: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3, 4} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:2: "global-settings".ethernet."access-mode"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:29: "network-based"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:47: "channel-based"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:58:64: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:2: "global-settings".ethernet."signal-updates"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:32: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:66: "always"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:76: "rx-only"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:66:87: "never"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:2: "global-settings".database."autosar-pdu-layer"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:35: "no-pdus"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:47: "from-autosar-4.0"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:68: "from-autosar-4.2"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1041:88: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:2: "global-settings".database."autosar-text-table-entries"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:44: "compu-const"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:60: "short-label"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1047:75: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:2: "global-settings".database."some-ip-pdus-without-service-context"
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:54: "ignore"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:65: "generate-service"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:1051:85: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
} -> *cuediscrim.LeafNode
choose({0, 1, 2})

./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:2: logging."test-trigger".scope
0: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:21: "test-unit"
1: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:35: "test-implementation-entity"
2: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:66: "test-case"
3: ./schemastore/src/schemas/json/venvironment-schema-v3.2.0.cue:76:79: =~"\\$\\{[a-zA-Z_][a-zA-Z0-9_]*\\}"
discriminate {0, 1, 2, 3} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3})
./schemastore/src/schemas/json/vtesttree-schema-v1.0.0.cue:45:9: _#defs."/definitions/75780/full"
0: ./schemastore/src/schemas/json/vtesttree-schema-v1.0.0.cue:45:47: {
	"capl-test-case"!: string
}
1: ./schemastore/src/schemas/json/vtesttree-schema-v1.0.0.cue:45:81: {
	"capl-test-sequence"!: string
}
2: ./schemastore/src/schemas/json/vtesttree-schema-v1.0.0.cue:45:115: {
	"test-group"!: string
}
discriminate {0, 1, 2} {
	----- PATH capl-test-case
	values:
	kinds:
		string: {0}
	----- PATH capl-test-sequence
	values:
	kinds:
		string: {1}
	----- PATH test-group
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH capl-test-case {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH capl-test-sequence {0, 2}; possible {1, 2}
	it's possible!
	----- PATH test-group {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(capl-test-case) -> {1, 2}
	notPresent(capl-test-sequence) -> {0, 2}
	notPresent(test-group) -> {0, 1}
}
./schemastore/src/schemas/json/vtesttree-schema-v2.0.0.cue:38:9: _#defs."/definitions/742a2/full"
0: ./schemastore/src/schemas/json/vtesttree-schema-v2.0.0.cue:38:47: {
	"capl-test-case"!: string
}
1: ./schemastore/src/schemas/json/vtesttree-schema-v2.0.0.cue:38:81: {
	"capl-test-sequence"!: string
}
2: ./schemastore/src/schemas/json/vtesttree-schema-v2.0.0.cue:38:115: {
	"test-fixture"!: string
}
discriminate {0, 1, 2} {
	----- PATH capl-test-case
	values:
	kinds:
		string: {0}
	----- PATH capl-test-sequence
	values:
	kinds:
		string: {1}
	----- PATH test-fixture
	values:
	kinds:
		string: {2}
	no pure discriminator found; trying existence checks; selected {0, 1, 2}
	----- PATH capl-test-case {1, 2}; possible {0, 1, 2}
	it's possible!
	----- PATH capl-test-sequence {0, 2}; possible {1, 2}
	it's possible!
	----- PATH test-fixture {0, 1}; possible {2}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(capl-test-case) -> {1, 2}
	notPresent(capl-test-sequence) -> {0, 2}
	notPresent(test-fixture) -> {0, 1}
}
./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:9: _#defs."/definitions/7690e/full"
0: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:47: {
	"capl-test-case"!: string
}
1: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:81: {
	"capl-test-sequence"!: string
}
2: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:115: {
	"dotnet-test-case"!: string
}
3: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:149: {
	"dotnet-test-sequence"!: string
}
4: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:183: {
	"python-test-case"!: string
}
5: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:217: {
	"python-test-sequence"!: string
}
6: ./schemastore/src/schemas/json/vtesttree-schema-v2.1.0.cue:100:251: {
	"test-fixture"!: string
}
discriminate {0, 1, 2, 3, 4, 5, 6} {
	----- PATH capl-test-case
	values:
	kinds:
		string: {0}
	----- PATH capl-test-sequence
	values:
	kinds:
		string: {1}
	----- PATH dotnet-test-case
	values:
	kinds:
		string: {2}
	----- PATH dotnet-test-sequence
	values:
	kinds:
		string: {3}
	----- PATH python-test-case
	values:
	kinds:
		string: {4}
	----- PATH python-test-sequence
	values:
	kinds:
		string: {5}
	----- PATH test-fixture
	values:
	kinds:
		string: {6}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6}
	----- PATH capl-test-case {1, 2, 3, 4, 5, 6}; possible {0, 1, 2, 3, 4, 5, 6}
	it's possible!
	----- PATH capl-test-sequence {0, 2, 3, 4, 5, 6}; possible {1, 2, 3, 4, 5, 6}
	it's possible!
	----- PATH dotnet-test-case {0, 1, 3, 4, 5, 6}; possible {2, 3, 4, 5, 6}
	it's possible!
	----- PATH dotnet-test-sequence {0, 1, 2, 4, 5, 6}; possible {3, 4, 5, 6}
	it's possible!
	----- PATH python-test-case {0, 1, 2, 3, 5, 6}; possible {4, 5, 6}
	it's possible!
	----- PATH python-test-sequence {0, 1, 2, 3, 4, 6}; possible {5, 6}
	it's possible!
	----- PATH test-fixture {0, 1, 2, 3, 4, 5}; possible {6}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(capl-test-case) -> {1, 2, 3, 4, 5, 6}
	notPresent(capl-test-sequence) -> {0, 2, 3, 4, 5, 6}
	notPresent(dotnet-test-case) -> {0, 1, 3, 4, 5, 6}
	notPresent(dotnet-test-sequence) -> {0, 1, 2, 4, 5, 6}
	notPresent(python-test-case) -> {0, 1, 2, 3, 5, 6}
	notPresent(python-test-sequence) -> {0, 1, 2, 3, 4, 6}
	notPresent(test-fixture) -> {0, 1, 2, 3, 4, 5}
}
./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:9: _#defs."/definitions/534ca/full"
0: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:47: {
	"capl-test-case"!: string
}
1: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:81: {
	"capl-test-sequence"!: string
}
2: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:115: {
	"dotnet-test-case"!: string
}
3: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:149: {
	"dotnet-test-sequence"!: string
}
4: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:183: {
	"python-test-case"!: string
}
5: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:217: {
	"python-test-sequence"!: string
}
6: ./schemastore/src/schemas/json/vtesttree-schema-v2.2.0.cue:40:251: {
	"test-fixture"!: string
}
discriminate {0, 1, 2, 3, 4, 5, 6} {
	----- PATH capl-test-case
	values:
	kinds:
		string: {0}
	----- PATH capl-test-sequence
	values:
	kinds:
		string: {1}
	----- PATH dotnet-test-case
	values:
	kinds:
		string: {2}
	----- PATH dotnet-test-sequence
	values:
	kinds:
		string: {3}
	----- PATH python-test-case
	values:
	kinds:
		string: {4}
	----- PATH python-test-sequence
	values:
	kinds:
		string: {5}
	----- PATH test-fixture
	values:
	kinds:
		string: {6}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6}
	----- PATH capl-test-case {1, 2, 3, 4, 5, 6}; possible {0, 1, 2, 3, 4, 5, 6}
	it's possible!
	----- PATH capl-test-sequence {0, 2, 3, 4, 5, 6}; possible {1, 2, 3, 4, 5, 6}
	it's possible!
	----- PATH dotnet-test-case {0, 1, 3, 4, 5, 6}; possible {2, 3, 4, 5, 6}
	it's possible!
	----- PATH dotnet-test-sequence {0, 1, 2, 4, 5, 6}; possible {3, 4, 5, 6}
	it's possible!
	----- PATH python-test-case {0, 1, 2, 3, 5, 6}; possible {4, 5, 6}
	it's possible!
	----- PATH python-test-sequence {0, 1, 2, 3, 4, 6}; possible {5, 6}
	it's possible!
	----- PATH test-fixture {0, 1, 2, 3, 4, 5}; possible {6}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(capl-test-case) -> {1, 2, 3, 4, 5, 6}
	notPresent(capl-test-sequence) -> {0, 2, 3, 4, 5, 6}
	notPresent(dotnet-test-case) -> {0, 1, 3, 4, 5, 6}
	notPresent(dotnet-test-sequence) -> {0, 1, 2, 4, 5, 6}
	notPresent(python-test-case) -> {0, 1, 2, 3, 5, 6}
	notPresent(python-test-sequence) -> {0, 1, 2, 3, 4, 6}
	notPresent(test-fixture) -> {0, 1, 2, 3, 4, 5}
}
./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:9: _#defs."/definitions/21bc6/full"
0: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:47: {
	"capl-test-case"!: string
}
1: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:81: {
	"capl-test-case-list"!: string
	"param-values"!: [[...], ...[...]]
}
2: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:115: {
	"capl-test-sequence"!: string
}
3: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:149: {
	"capl-test-sequence-list"!: string
	"param-values"!: [[...], ...[...]]
}
4: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:183: {
	"dotnet-test-case"!: string
}
5: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:217: {
	"dotnet-test-case-list"!: string
	"param-values"!: [[...], ...[...]]
}
6: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:251: {
	"dotnet-test-sequence"!: string
}
7: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:285: {
	"dotnet-test-sequence-list"!: string
	"param-values"!: [[...], ...[...]]
}
8: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:319: {
	"python-test-case"!: string
}
9: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:353: {
	"python-test-case-list"!: string
	"param-values"!: [[...], ...[...]]
}
10: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:387: {
	"python-test-sequence"!: string
}
11: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:421: {
	"python-test-sequence-list"!: string
	"param-values"!: [[...], ...[...]]
}
12: ./schemastore/src/schemas/json/vtesttree-schema-v2.3.0.cue:25:455: {
	"test-fixture"!: string
}
discriminate {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} {
	----- PATH capl-test-case
	values:
	kinds:
		string: {0}
	----- PATH capl-test-case-list
	values:
	kinds:
		string: {1}
	----- PATH param-values
	values:
	kinds:
		list: {1, 3, 5, 7, 9, 11}
	----- PATH capl-test-sequence
	values:
	kinds:
		string: {2}
	----- PATH capl-test-sequence-list
	values:
	kinds:
		string: {3}
	----- PATH dotnet-test-case
	values:
	kinds:
		string: {4}
	----- PATH dotnet-test-case-list
	values:
	kinds:
		string: {5}
	----- PATH dotnet-test-sequence
	values:
	kinds:
		string: {6}
	----- PATH dotnet-test-sequence-list
	values:
	kinds:
		string: {7}
	----- PATH python-test-case
	values:
	kinds:
		string: {8}
	----- PATH python-test-case-list
	values:
	kinds:
		string: {9}
	----- PATH python-test-sequence
	values:
	kinds:
		string: {10}
	----- PATH python-test-sequence-list
	values:
	kinds:
		string: {11}
	----- PATH test-fixture
	values:
	kinds:
		string: {12}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	----- PATH capl-test-case {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; possible {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH capl-test-case-list {0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; possible {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH param-values {0, 2, 4, 6, 8, 10, 12}; possible {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	----- PATH capl-test-sequence {0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; possible {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH capl-test-sequence-list {0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12}; possible {3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH dotnet-test-case {0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12}; possible {4, 5, 6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH dotnet-test-case-list {0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12}; possible {5, 6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH dotnet-test-sequence {0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12}; possible {6, 7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH dotnet-test-sequence-list {0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12}; possible {7, 8, 9, 10, 11, 12}
	it's possible!
	----- PATH python-test-case {0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12}; possible {8, 9, 10, 11, 12}
	it's possible!
	----- PATH python-test-case-list {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12}; possible {9, 10, 11, 12}
	it's possible!
	----- PATH python-test-sequence {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}; possible {10, 11, 12}
	it's possible!
	----- PATH python-test-sequence-list {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}; possible {11, 12}
	it's possible!
	----- PATH test-fixture {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; possible {12}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(capl-test-case) -> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	notPresent(capl-test-case-list) -> {0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	notPresent(capl-test-sequence) -> {0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	notPresent(capl-test-sequence-list) -> {0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12}
	notPresent(dotnet-test-case) -> {0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12}
	notPresent(dotnet-test-case-list) -> {0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12}
	notPresent(dotnet-test-sequence) -> {0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12}
	notPresent(dotnet-test-sequence-list) -> {0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12}
	notPresent(python-test-case) -> {0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12}
	notPresent(python-test-case-list) -> {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12}
	notPresent(python-test-sequence) -> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}
	notPresent(python-test-sequence-list) -> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
	notPresent(test-fixture) -> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
}
./schemastore/src/schemas/json/warp-themes.cue:47:4: #."color-or-gradient"
0: ./schemastore/src/schemas/json/warp-themes.cue:47:36: =~"^#[0-9a-fA-F]{6}$"
1: ./schemastore/src/schemas/json/warp-themes.cue:47:55: {}
2: ./schemastore/src/schemas/json/warp-themes.cue:50:5: {}
discriminate {0, 1, 2} {
	kind string: {0}
	discriminate {0} {
	} -> *cuediscrim.LeafNode
	kind struct: {1, 2}
	discriminate {1, 2} {
		no pure discriminator found; trying existence checks; selected {1, 2}
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({0})
case struct:
	choose({1, 2})
}
./schemastore/src/schemas/json/web-manifest.cue:33:1: orientation
0: ./schemastore/src/schemas/json/web-manifest.cue:33:26: _
1: ./schemastore/src/schemas/json/web-manifest.cue:33:29: _
2: ./schemastore/src/schemas/json/web-manifest.cue:33:32: _
3: ./schemastore/src/schemas/json/web-manifest.cue:33:35: _
4: ./schemastore/src/schemas/json/web-manifest.cue:33:38: _
5: ./schemastore/src/schemas/json/web-manifest.cue:33:41: _
6: ./schemastore/src/schemas/json/web-manifest.cue:33:44: _
7: ./schemastore/src/schemas/json/web-manifest.cue:33:47: _
discriminate {0, 1, 2, 3, 4, 5, 6, 7} {
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3, 4, 5, 6, 7}
} -> *cuediscrim.LeafNode
choose({0, 1, 2, 3, 4, 5, 6, 7})

./schemastore/src/schemas/json/web-manifest.cue:96:2: #manifest_image_resource.sizes
0: ./schemastore/src/schemas/json/web-manifest.cue:96:21: =~"^[0-9 x]+$"
1: ./schemastore/src/schemas/json/web-manifest.cue:96:37: "any"
discriminate {0, 1} {
	no pure discriminator found; trying existence checks; selected {0, 1}
} -> *cuediscrim.LeafNode
choose({0, 1})
./schemastore/src/schemas/json/web-types.cue:415:4: #."name-pattern"
0: ./schemastore/src/schemas/json/web-types.cue:415:31: {}
1: ./schemastore/src/schemas/json/web-types.cue:426:5: {
	regex!: string
}
discriminate {0, 1} {
	----- PATH regex
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH regex {0}; possible {0, 1}
	it's possible!
} -> *cuediscrim.LeafNode
choose({0, 1})

./schemastore/src/schemas/json/web-types.cue:431:4: #."name-pattern-root"
0: ./schemastore/src/schemas/json/web-types.cue:415:31: {}
1: ./schemastore/src/schemas/json/web-types.cue:426:5: {
	regex!: string
}
2: ./schemastore/src/schemas/json/web-types.cue:431:54: string
discriminate {0, 1, 2} {
	kind struct: {0, 1}
	discriminate {0, 1} {
		----- PATH regex
		values:
		kinds:
			string: {1}
		no pure discriminator found; trying existence checks; selected {0, 1}
		----- PATH regex {0}; possible {0, 1}
		it's possible!
	} -> *cuediscrim.LeafNode
	kind string: {2}
	discriminate {2} {
	} -> *cuediscrim.LeafNode
} -> *cuediscrim.KindSwitchNode
switch kind(.) {
case string:
	choose({2})
case struct:
	choose({0, 1})
}

./schemastore/src/schemas/json/web-types.cue:476:4: #."required-context"
0: ./schemastore/src/schemas/json/web-types.cue:476:35: {
	kind!: string
	name!: string
}
1: ./schemastore/src/schemas/json/web-types.cue:479:5: {
	anyOf!: [...]
}
2: ./schemastore/src/schemas/json/web-types.cue:481:5: {
	allOf!: [...]
}
3: ./schemastore/src/schemas/json/web-types.cue:483:5: {
	not!: matchN(1, [close({
		kind!: string
		name!: string
	}), close({
		anyOf!: [...#."required-context"]
	}), close({
		allOf!: [...#."required-context"]
	}), close({
		not!: #."required-context"
	})])
}
discriminate {0, 1, 2, 3} {
	----- PATH kind
	values:
	kinds:
		string: {0}
	----- PATH name
	values:
	kinds:
		string: {0}
	----- PATH anyOf
	values:
	kinds:
		list: {1}
	----- PATH allOf
	values:
	kinds:
		list: {2}
	----- PATH not
	values:
	kinds:
		string: {3}
		bytes: {3}
		list: {3}
		struct: {3}
		null: {3}
		bool: {3}
		int: {3}
		float: {3}
	no pure discriminator found; trying existence checks; selected {0, 1, 2, 3}
	----- PATH kind {1, 2, 3}; possible {0, 1, 2, 3}
	it's possible!
	----- PATH name {1, 2, 3}; possible {1, 2, 3}
	it's possible!
	nothing removed
	----- PATH anyOf {0, 2, 3}; possible {1, 2, 3}
	it's possible!
	----- PATH allOf {0, 1, 3}; possible {2, 3}
	it's possible!
	----- PATH not {0, 1, 2}; possible {3}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(allOf) -> {0, 1, 3}
	notPresent(anyOf) -> {0, 2, 3}
	notPresent(kind) -> {1, 2, 3}
	notPresent(not) -> {0, 1, 2}
}

./schemastore/src/schemas/json/web-types.cue:609:1: #source
0: ./schemastore/src/schemas/json/web-types.cue:609:21: {
	file!:   string
	offset!: int
}
1: ./schemastore/src/schemas/json/web-types.cue:616:5: {
	symbol!: string
}
discriminate {0, 1} {
	----- PATH file
	values:
	kinds:
		string: {0}
	----- PATH offset
	values:
	kinds:
		int: {0}
	----- PATH symbol
	values:
	kinds:
		string: {1}
	no pure discriminator found; trying existence checks; selected {0, 1}
	----- PATH file {1}; possible {0, 1}
	it's possible!
	----- PATH offset {1}; possible {1}
	it's possible!
	nothing removed
	----- PATH symbol {0}; possible {1}
	it's possible!
} -> *cuediscrim.FieldAbsenceNode
allOf {
	notPresent(file) -> {1}
	notPresent(symbol) -> {0}
}
